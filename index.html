<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Inversion & Zeta Swarm</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- Load Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-950 text-slate-100 font-sans overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Inline Icons ---
        const Activity = ({size=24}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>;
        const Play = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const Pause = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const Settings = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>;
        const TargetIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>;
        const RefreshCw = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;
        const BoxIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const NetworkIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>;

        // ==========================================
        // TAB 1: ORIGINAL BILLIARD INVERSION
        // ==========================================
        const BilliardSim = () => {
          const [isRunning, setIsRunning] = useState(false);
          const [precision, setPrecision] = useState(0.001);
          const [inversionRadius, setInversionRadius] = useState(150);
          const [speed, setSpeed] = useState(2);
          const [windingNumber, setWindingNumber] = useState(0);
          const [cornerHits, setCornerHits] = useState(0);
          const [trailLength, setTrailLength] = useState(5000);
          const [showInversionCircle, setShowInversionCircle] = useState(true);

          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const stateRef = useRef({ pos: { x: 50, y: 50 }, vel: { x: 1.5, y: 1.2 }, path: [], bounds: { size: 300 } });

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              const container = canvas.parentElement;
              if (container) { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100); 
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const invertPoint = (x, y, cx, cy, r) => {
            const dx = x - cx; const dy = y - cy; const distSq = dx * dx + dy * dy;
            if (distSq === 0) return { x, y };
            const factor = (r * r) / distSq;
            return { x: cx + dx * factor, y: cy + dy * factor };
          };

          const update = () => {
            const s = stateRef.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const cx = canvas.width / 2; const cy = canvas.height / 2; const halfSize = s.bounds.size / 2;

            for (let i = 0; i < speed; i++) {
              s.pos.x += s.vel.x; s.pos.y += s.vel.y;
              const left = cx - halfSize; const right = cx + halfSize; const top = cy - halfSize; const bottom = cy + halfSize;
              let hitCornerX = false; let hitCornerY = false;

              if (s.pos.x <= left || s.pos.x >= right) {
                s.vel.x *= -1; s.pos.x = s.pos.x <= left ? left : right;
                if (Math.abs(s.pos.y - top) < 5 || Math.abs(s.pos.y - bottom) < 5) hitCornerX = true;
              }
              if (s.pos.y <= top || s.pos.y >= bottom) {
                s.vel.y *= -1; s.pos.y = s.pos.y <= top ? top : bottom;
                if (Math.abs(s.pos.x - left) < 5 || Math.abs(s.pos.x - right) < 5) hitCornerY = true;
              }

              if (hitCornerX || hitCornerY) {
                setCornerHits(prev => prev + 1);
                setWindingNumber(prev => prev + (s.vel.x * s.vel.y > 0 ? 1 : -1));
              }

              const inverted = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
              s.path.push(inverted);
              if (s.path.length > trailLength) s.path.shift();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (showInversionCircle) {
              ctx.beginPath(); ctx.arc(cx, cy, inversionRadius, 0, Math.PI * 2);
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }

            ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
            ctx.strokeRect(cx - halfSize, cy - halfSize, s.bounds.size, s.bounds.size);

            if (s.path.length > 1) {
              ctx.beginPath(); ctx.moveTo(s.path[0].x, s.path[0].y);
              for (let i = 1; i < s.path.length; i++) ctx.lineTo(s.path[i].x, s.path[i].y);
              const gradient = ctx.createRadialGradient(cx, cy, 10, cx, cy, inversionRadius * 2);
              gradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)'); gradient.addColorStop(1, 'rgba(236, 72, 153, 0.1)');
              ctx.strokeStyle = gradient; ctx.lineWidth = 1.5; ctx.stroke();
            }

            const currentInv = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
            ctx.beginPath(); ctx.arc(currentInv.x, currentInv.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#f472b6'; ctx.shadowBlur = 10; ctx.shadowColor = '#f472b6'; ctx.fill(); ctx.shadowBlur = 0;

            requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning, speed, inversionRadius, trailLength]);

          const resetSimulation = () => {
            if (canvasRef.current) {
              stateRef.current.path = [];
              stateRef.current.pos = { x: canvasRef.current.width / 2 + 20, y: canvasRef.current.height / 2 + 20 };
              setCornerHits(0); setWindingNumber(0);
            }
          };

          return (
            <div className="flex-1 flex flex-col md:flex-row relative overflow-hidden">
                <aside className="w-full md:w-80 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10 max-h-[35vh] md:max-h-none">
                  <section className="space-y-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-indigo-400">Controls</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-indigo-500'}`}>{isRunning ? 'Pause' : 'Start'}</button>
                    </div>
                    <div>
                      <div className="space-y-4">
                        <div className="space-y-2">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Inversion Radius</label><span className="text-indigo-400 font-mono">{inversionRadius}px</span></div>
                          <input type="range" min="50" max="300" value={inversionRadius} onChange={(e) => setInversionRadius(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                        <div className="space-y-2">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Speed</label><span className="text-indigo-400 font-mono">x{speed}</span></div>
                          <input type="range" min="1" max="10" value={speed} onChange={(e) => setSpeed(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                      </div>
                    </div>
                    <div className="pt-4 border-t border-slate-800 space-y-3">
                        <label className="flex items-center justify-between p-2 md:p-3 bg-slate-800/30 rounded-xl cursor-pointer hover:bg-slate-800/50">
                          <span className="text-xs md:text-sm font-medium">Show Inversion Circle</span>
                          <input type="checkbox" checked={showInversionCircle} onChange={() => setShowInversionCircle(!showInversionCircle)} className="w-4 h-4 rounded accent-indigo-500" />
                        </label>
                        <button onClick={resetSimulation} className="w-full flex items-center justify-center gap-2 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-slate-300 font-semibold text-sm">
                          <RefreshCw size={14} /> Reset Path
                        </button>
                    </div>
                  </section>
                </aside>

                <div className="flex-1 min-h-[50vh] bg-[radial-gradient(circle_at_center,_#111827_0%,_#020617_100%)] relative">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                  <div className="absolute bottom-4 left-4 right-4 flex justify-between items-end pointer-events-none">
                    <div className="bg-slate-900/80 backdrop-blur-md border border-slate-800 p-3 rounded-xl min-w-[150px] shadow-2xl">
                      <div className="flex justify-between text-xs mb-1"><span className="text-slate-500">Winding</span><span className="text-emerald-400 font-mono">{windingNumber}</span></div>
                      <div className="flex justify-between text-xs"><span className="text-slate-500">Corners</span><span className="text-amber-400 font-mono">{cornerHits}</span></div>
                    </div>
                  </div>
                </div>
            </div>
          );
        };

        // ==========================================
        // TAB 2: ZETA SWARM (SMITH & BLADE LOGIC)
        // ==========================================
        const ZetaSwarmSim = () => {
          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const [zetaSorted, setZetaSorted] = useState(0);
          const [isRunning, setIsRunning] = useState(true);

          // State references so animation loop can use them without dependency triggering
          const simState = useRef({
            bots: [],
            visitedNodes: [], // Global memory "where they have looked"
            zetaTargets: [],
            lastSpawn: 0
          });

          // Initialize the Swarm
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              const container = canvas.parentElement;
              if (container) { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);

            // Initialize Bots
            const bots = [];
            // Group 1: 3 bots (Upward) - Cyan
            for(let i=0; i<3; i++) bots.push({ id: `g1_${i}`, group: 1, x: window.innerWidth/2 + (Math.random()-0.5)*100, y: window.innerHeight - 100, vx: (Math.random()-0.5)*2, vy: -2 - Math.random(), color: '#22d3ee', size: 4 });
            // Group 2: 5 bots (Downward) - Rose
            for(let i=0; i<5; i++) bots.push({ id: `g2_${i}`, group: 2, x: window.innerWidth/2 + (Math.random()-0.5)*200, y: 100, vx: (Math.random()-0.5)*2, vy: 2 + Math.random(), color: '#fb7185', size: 3 });
            // Group 3: 7 bots (Radial Choice) - Amber
            for(let i=0; i<7; i++) {
                const angle = (i / 7) * Math.PI * 2;
                bots.push({ id: `g3_${i}`, group: 3, x: window.innerWidth/2, y: window.innerHeight/2, vx: Math.cos(angle)*1.5, vy: Math.sin(angle)*1.5, color: '#fbbf24', size: 3 });
            }
            simState.current.bots = bots;

            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const update = () => {
            const s = simState.current;
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const cw = canvas.width; const ch = canvas.height;

            // Spawn Zeta Numbers (data to sort)
            if (Date.now() - s.lastSpawn > 1000 && s.zetaTargets.length < 30) {
                s.zetaTargets.push({ x: Math.random() * cw, y: Math.random() * ch, val: Math.floor(Math.random()*1000) });
                s.lastSpawn = Date.now();
            }

            // --- SMITH AND BLADE LOGIC (Update Bots) ---
            s.bots.forEach(bot => {
                // 1. Avoid explored areas (Shared Global Map)
                let repulseX = 0; let repulseY = 0;
                s.visitedNodes.forEach(node => {
                    const dx = bot.x - node.x; const dy = bot.y - node.y;
                    const distSq = dx*dx + dy*dy;
                    if (distSq < 4000) { // If within 60px of a visited node
                        const dist = Math.sqrt(distSq);
                        repulseX += (dx/dist) * 0.5; // push away
                        repulseY += (dy/dist) * 0.5;
                    }
                });

                // 2. Seek nearest Zeta target
                let attractX = 0; let attractY = 0;
                let nearestZeta = null; let minDist = Infinity;
                s.zetaTargets.forEach((target, index) => {
                    const dx = target.x - bot.x; const dy = target.y - bot.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 100 && dist < minDist) { minDist = dist; nearestZeta = index; attractX = dx/dist; attractY = dy/dist; }
                    
                    // Collect Zeta Data
                    if (dist < 15) {
                        s.zetaTargets.splice(index, 1);
                        setZetaSorted(prev => prev + 1);
                    }
                });

                // 3. Directional Directives based on Group
                let dirX = 0; let dirY = 0;
                if (bot.group === 1) dirY = -0.5; // Group 1 goes UP
                if (bot.group === 2) dirY = 0.5;  // Group 2 goes DOWN
                if (bot.group === 3) {            // Group 3 goes OUTWARD (from center)
                    dirX = (bot.x - cw/2) > 0 ? 0.2 : -0.2;
                    dirY = (bot.y - ch/2) > 0 ? 0.2 : -0.2;
                }

                // Apply forces
                bot.vx += repulseX + attractX * 0.5 + dirX;
                bot.vy += repulseY + attractY * 0.5 + dirY;

                // Friction/Speed limit
                const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                if (speed > 3) { bot.vx = (bot.vx/speed)*3; bot.vy = (bot.vy/speed)*3; }

                // Move
                bot.x += bot.vx; bot.y += bot.vy;

                // Bounce off walls
                if (bot.x < 0 || bot.x > cw) bot.vx *= -1;
                if (bot.y < 0 || bot.y > ch) bot.vy *= -1;

                // Mark global memory every few frames
                if (Math.random() < 0.1) {
                    s.visitedNodes.push({x: bot.x, y: bot.y, age: 255});
                    if (s.visitedNodes.length > 200) s.visitedNodes.shift(); // Keep memory lean
                }
            });

            // Fade memory
            s.visitedNodes.forEach(n => n.age -= 1);
            s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            // --- RENDER ---
            ctx.fillStyle = 'rgba(15, 23, 42, 0.3)'; // Trail effect background
            ctx.fillRect(0, 0, cw, ch);

            // Draw Shared Memory Map (Where they have looked)
            s.visitedNodes.forEach(node => {
                ctx.beginPath(); ctx.arc(node.x, node.y, 2, 0, Math.PI*2);
                ctx.fillStyle = `rgba(255, 255, 255, ${node.age/1000})`; ctx.fill();
            });

            // Draw Zeta Targets
            s.zetaTargets.forEach(target => {
                ctx.beginPath();
                ctx.rect(target.x-4, target.y-4, 8, 8);
                ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 1; ctx.stroke();
                ctx.fillStyle = 'rgba(74, 222, 128, 0.2)'; ctx.fill();
            });

            // Draw Bot Communication Lines (Groups talking)
            ctx.lineWidth = 0.5;
            for(let i=0; i<s.bots.length; i++) {
                for(let j=i+1; j<s.bots.length; j++) {
                    const b1 = s.bots[i]; const b2 = s.bots[j];
                    if (b1.group === b2.group) { // Talk within group
                        const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                        if (dx*dx + dy*dy < 20000) {
                            ctx.beginPath(); ctx.moveTo(b1.x, b1.y); ctx.lineTo(b2.x, b2.y);
                            ctx.strokeStyle = b1.color + '40'; // 25% opacity
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw Bots
            s.bots.forEach(bot => {
                ctx.beginPath(); ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI*2);
                ctx.fillStyle = bot.color; ctx.shadowBlur = 10; ctx.shadowColor = bot.color; ctx.fill();
                ctx.shadowBlur = 0;
            });

            if (isRunning) requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning]);

          return (
             <div className="flex-1 flex flex-col md:flex-row relative overflow-hidden">
                <aside className="w-full md:w-80 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10">
                  <section className="space-y-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-emerald-400">Swarm Protocol</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-emerald-500'}`}>{isRunning ? 'Halt 24/7' : 'Resume 24/7'}</button>
                    </div>

                    <div className="p-4 bg-slate-800/50 rounded-xl border border-slate-700">
                        <div className="text-xs text-slate-400 uppercase font-bold mb-1">Zeta Numbers Sorted</div>
                        <div className="text-3xl font-mono text-emerald-400">{zetaSorted.toLocaleString()}</div>
                        <div className="text-[10px] text-slate-500 mt-2">Continuous 24/7 parsing via Smith & Blade logic.</div>
                    </div>

                    <div className="space-y-3">
                        <h3 className="text-xs font-bold uppercase tracking-wider text-slate-500 mb-2">Active Squads</h3>
                        
                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-cyan-500/20">
                            <div className="w-3 h-3 rounded-full bg-cyan-400 shadow-[0_0_8px_rgba(34,211,238,0.8)]"></div>
                            <div>
                                <div className="text-sm font-bold text-slate-200">Group 1 (3 Bots)</div>
                                <div className="text-[10px] text-slate-400 uppercase">Directive: Upward Sweep</div>
                            </div>
                        </div>

                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-rose-500/20">
                            <div className="w-3 h-3 rounded-full bg-rose-400 shadow-[0_0_8px_rgba(251,113,133,0.8)]"></div>
                            <div>
                                <div className="text-sm font-bold text-slate-200">Group 2 (5 Bots)</div>
                                <div className="text-[10px] text-slate-400 uppercase">Directive: Downward Sweep</div>
                            </div>
                        </div>

                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-amber-500/20">
                            <div className="w-3 h-3 rounded-full bg-amber-400 shadow-[0_0_8px_rgba(251,191,36,0.8)]"></div>
                            <div>
                                <div className="text-sm font-bold text-slate-200">Group 3 (7 Bots)</div>
                                <div className="text-[10px] text-slate-400 uppercase">Directive: Radial Expansion</div>
                            </div>
                        </div>
                    </div>
                  </section>
                </aside>

                <div className="flex-1 min-h-[50vh] bg-slate-950 relative">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                  
                  {/* Overlay Legend */}
                  <div className="absolute bottom-4 right-4 bg-slate-900/80 backdrop-blur border border-slate-800 p-3 rounded-xl pointer-events-none">
                     <div className="flex items-center gap-2 text-xs text-slate-400 mb-1"><span className="w-2 h-2 rounded-full bg-white opacity-50"></span> Shared Memory Path</div>
                     <div className="flex items-center gap-2 text-xs text-slate-400"><span className="w-2 h-2 rounded-sm bg-green-400/50 border border-green-400"></span> Zeta Data Target</div>
                  </div>
                </div>
             </div>
          );
        };

        // ==========================================
        // MAIN APP CONTAINER (TAB LOGIC)
        // ==========================================
        const App = () => {
          const [activeTab, setActiveTab] = useState(1);

          return (
            <div className="flex flex-col h-screen bg-slate-950 text-slate-100 font-sans overflow-hidden">
              <header className="flex flex-col md:flex-row items-start md:items-center justify-between px-4 md:px-6 py-3 bg-slate-900/80 border-b border-slate-800 backdrop-blur-md z-20 gap-4">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-indigo-500/20 rounded-lg text-indigo-400">
                    <Activity size={24} />
                  </div>
                  <div>
                    <h1 className="text-lg md:text-xl font-bold tracking-tight">Project Genesis</h1>
                    <p className="text-[10px] md:text-xs text-slate-400 uppercase tracking-widest font-medium">Multi-System Simulation</p>
                  </div>
                </div>

                {/* Tab Navigation */}
                <div className="flex bg-slate-800/50 p-1 rounded-xl w-full md:w-auto">
                    <button 
                        onClick={() => setActiveTab(1)}
                        className={`flex-1 md:flex-none flex items-center justify-center gap-2 px-6 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 1 ? 'bg-indigo-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}
                    >
                        <BoxIcon size={16} /> Billiard Inversion
                    </button>
                    <button 
                        onClick={() => setActiveTab(2)}
                        className={`flex-1 md:flex-none flex items-center justify-center gap-2 px-6 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 2 ? 'bg-emerald-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}
                    >
                        <NetworkIcon size={16} /> Zeta Swarm
                    </button>
                </div>
              </header>

              <main className="flex-1 flex flex-col relative overflow-hidden">
                {activeTab === 1 && <BilliardSim />}
                {activeTab === 2 && <ZetaSwarmSim />}
              </main>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>