<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Genesis: Holography & Swarm Logic</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- Load Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-950 text-slate-100 font-sans overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Inline Icons ---
        const Activity = ({size=24}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>;
        const Play = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const Pause = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const RefreshCw = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;
        const BoxIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const NetworkIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>;
        const HeartPulse = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"></path><path d="M3.22 12H9.5l.5-1 2 4.5 2-7 1.5 3.5h5.27"></path></svg>;
        const CpuIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>;

        // ==========================================
        // TAB 1: BILLIARD INVERSION (RESPONSIVE)
        // ==========================================
        const BilliardSim = () => {
          const [isRunning, setIsRunning] = useState(false);
          const [inversionRadius, setInversionRadius] = useState(100);
          const [speed, setSpeed] = useState(2);
          const [windingNumber, setWindingNumber] = useState(0);
          const [cornerHits, setCornerHits] = useState(0);
          const [configsRegistered, setConfigsRegistered] = useState(0);
          const [trailLength, setTrailLength] = useState(3000);
          const [showInversionCircle, setShowInversionCircle] = useState(true);
          const [showDynamicGrid, setShowDynamicGrid] = useState(true);

          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const stateRef = useRef({ 
            pos: { x: null, y: null }, vel: { x: 1.8, y: 1.3 }, 
            stdPath: [], invPath: [], gridPhase: 0, configCounter: 0, frameCount: 0 
          });

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              const container = canvas.parentElement;
              if (container) { 
                canvas.width = container.clientWidth; 
                canvas.height = container.clientHeight; 
                if (!stateRef.current.pos.x) {
                  stateRef.current.pos = { x: canvas.width/2, y: canvas.height/2 };
                }
              }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100); 
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const invertPoint = (x, y, cx, cy, r) => {
            const dx = x - cx; const dy = y - cy; const distSq = dx * dx + dy * dy;
            if (distSq === 0) return { x, y };
            const factor = (r * r) / distSq;
            return { x: cx + dx * factor, y: cy + dy * factor };
          };

          const update = () => {
            const s = stateRef.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const cw = canvas.width; const ch = canvas.height;
            const cx = cw / 2; const cy = ch / 2; 
            
            const boundSize = Math.min(cw, ch) * 0.55; 
            const halfSize = boundSize / 2;

            if (s.pos.x === null) s.pos = { x: cx, y: cy };

            for (let i = 0; i < speed; i++) {
              s.pos.x += s.vel.x; s.pos.y += s.vel.y;
              
              const left = cx - halfSize; const right = cx + halfSize; 
              const top = cy - halfSize; const bottom = cy + halfSize;
              let hitCornerX = false; let hitCornerY = false;

              if (s.pos.x <= left) { s.vel.x *= -1; s.pos.x = left + 1; hitCornerX = Math.abs(s.pos.y - top) < 15 || Math.abs(s.pos.y - bottom) < 15; }
              else if (s.pos.x >= right) { s.vel.x *= -1; s.pos.x = right - 1; hitCornerX = Math.abs(s.pos.y - top) < 15 || Math.abs(s.pos.y - bottom) < 15; }
              
              if (s.pos.y <= top) { s.vel.y *= -1; s.pos.y = top + 1; hitCornerY = Math.abs(s.pos.x - left) < 15 || Math.abs(s.pos.x - right) < 15; }
              else if (s.pos.y >= bottom) { s.vel.y *= -1; s.pos.y = bottom - 1; hitCornerY = Math.abs(s.pos.x - left) < 15 || Math.abs(s.pos.x - right) < 15; }

              if (hitCornerX || hitCornerY) {
                setCornerHits(prev => prev + 1);
                setWindingNumber(prev => prev + (s.vel.x * s.vel.y > 0 ? 1 : -1));
              }

              s.stdPath.push({x: s.pos.x, y: s.pos.y});
              if (s.stdPath.length > trailLength) s.stdPath.shift();

              const inverted = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
              s.invPath.push(inverted);
              if (s.invPath.length > trailLength) s.invPath.shift();
            }

            s.gridPhase += 0.05 * speed;
            s.configCounter += Math.floor(speed * 4);
            s.frameCount++;
            if (s.frameCount % 10 === 0) setConfigsRegistered(s.configCounter);

            ctx.clearRect(0, 0, cw, ch);

            // Draw Static Background Grid for visual context
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<cw; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,ch); }
            for(let y=0; y<ch; y+=40) { ctx.moveTo(0,y); ctx.lineTo(cw,y); }
            ctx.stroke();

            // Draw Dynamic Configuration Grid inside boundary
            if (showDynamicGrid) {
              ctx.strokeStyle = 'rgba(56, 189, 248, 0.08)'; 
              ctx.lineWidth = 1;
              ctx.beginPath();
              const phaseOffset = Math.sin(s.gridPhase) * 20;
              for(let i = -halfSize; i <= halfSize; i+=30) {
                  let x = cx + i + phaseOffset;
                  if (x > cx - halfSize && x < cx + halfSize) { ctx.moveTo(x, cy - halfSize); ctx.lineTo(x, cy + halfSize); }
                  let y = cy + i + Math.cos(s.gridPhase) * 20;
                  if (y > cy - halfSize && y < cy + halfSize) { ctx.moveTo(cx - halfSize, y); ctx.lineTo(cx + halfSize, y); }
              }
              ctx.stroke();
            }

            if (showInversionCircle) {
              ctx.beginPath(); ctx.arc(cx, cy, inversionRadius, 0, Math.PI * 2);
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }

            ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.strokeRect(cx - halfSize, cy - halfSize, boundSize, boundSize);

            if (s.stdPath.length > 1) {
              ctx.beginPath(); ctx.moveTo(s.stdPath[0].x, s.stdPath[0].y);
              for (let i = 1; i < s.stdPath.length; i++) ctx.lineTo(s.stdPath[i].x, s.stdPath[i].y);
              ctx.strokeStyle = 'rgba(56, 189, 248, 0.4)'; ctx.lineWidth = 1; ctx.stroke();
            }

            if (s.invPath.length > 1) {
              ctx.beginPath(); ctx.moveTo(s.invPath[0].x, s.invPath[0].y);
              for (let i = 1; i < s.invPath.length; i++) ctx.lineTo(s.invPath[i].x, s.invPath[i].y);
              const gradient = ctx.createRadialGradient(cx, cy, 10, cx, cy, inversionRadius * 2);
              gradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)'); gradient.addColorStop(1, 'rgba(236, 72, 153, 0.1)');
              ctx.strokeStyle = gradient; ctx.lineWidth = 1.5; ctx.stroke();
            }

            ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#38bdf8'; ctx.shadowBlur = 10; ctx.shadowColor = '#38bdf8'; ctx.fill(); ctx.shadowBlur = 0;

            const currentInv = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
            ctx.beginPath(); ctx.arc(currentInv.x, currentInv.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#f472b6'; ctx.shadowBlur = 10; ctx.shadowColor = '#f472b6'; ctx.fill(); ctx.shadowBlur = 0;

            requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning, speed, inversionRadius, trailLength, showDynamicGrid]);

          return (
            <div className="flex-1 flex flex-col md:flex-row relative min-h-0 overflow-hidden">
                <aside className="w-full md:w-72 flex-shrink-0 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10 max-h-[45%] md:max-h-none">
                  <section className="space-y-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-indigo-400">Controls</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-indigo-500'}`}>{isRunning ? 'Pause' : 'Start'}</button>
                    </div>
                    <div>
                      <div className="space-y-4">
                        <div className="space-y-2">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Inversion Radius</label><span className="text-indigo-400 font-mono">{inversionRadius}px</span></div>
                          <input type="range" min="30" max="250" value={inversionRadius} onChange={(e) => setInversionRadius(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                        <div className="space-y-2">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Speed</label><span className="text-indigo-400 font-mono">x{speed}</span></div>
                          <input type="range" min="1" max="10" value={speed} onChange={(e) => setSpeed(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                      </div>
                    </div>
                    <div className="pt-4 border-t border-slate-800 space-y-3">
                        <label className="flex items-center justify-between p-2 md:p-3 bg-slate-800/30 rounded-xl cursor-pointer hover:bg-slate-800/50">
                          <span className="text-xs md:text-sm font-medium">Dual Geometry Mesh</span>
                          <input type="checkbox" checked={showDynamicGrid} onChange={() => setShowDynamicGrid(!showDynamicGrid)} className="w-4 h-4 rounded accent-indigo-500" />
                        </label>
                        <button onClick={() => { stateRef.current.stdPath = []; stateRef.current.invPath = []; setCornerHits(0); setWindingNumber(0); stateRef.current.configCounter = 0; setConfigsRegistered(0); }} className="w-full flex items-center justify-center gap-2 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-slate-300 font-semibold text-sm">
                          <RefreshCw size={14} /> Reset Path
                        </button>
                    </div>
                  </section>
                </aside>

                <div className="flex-1 relative min-h-0 bg-[radial-gradient(circle_at_center,_#111827_0%,_#020617_100%)]">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                  <div className="absolute bottom-4 left-4 right-4 flex justify-between items-end pointer-events-none">
                    <div className="bg-slate-900/80 backdrop-blur-md border border-slate-800 p-3 rounded-xl min-w-[200px] shadow-2xl">
                      <div className="flex justify-between text-xs mb-1"><span className="text-slate-500">Free Configs</span><span className="text-sky-400 font-mono">{configsRegistered.toLocaleString()}</span></div>
                      <div className="flex justify-between text-xs mb-1"><span className="text-slate-500">Winding</span><span className="text-emerald-400 font-mono">{windingNumber}</span></div>
                      <div className="flex justify-between text-xs"><span className="text-slate-500">Corners</span><span className="text-amber-400 font-mono">{cornerHits}</span></div>
                    </div>
                  </div>
                </div>
            </div>
          );
        };

        // ==========================================
        // TAB 2: ZETA SWARM (SMITH & BLADE LOGIC)
        // ==========================================
        const ZetaSwarmSim = () => {
          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const [zetaSorted, setZetaSorted] = useState(0);
          const [isRunning, setIsRunning] = useState(true);

          const simState = useRef({ bots: [], visitedNodes: [], zetaTargets: [], lastSpawn: 0 });

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => { if (canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; } };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);

            const bots = [];
            for(let i=0; i<3; i++) bots.push({ id: `g1_${i}`, group: 1, x: window.innerWidth/2, y: window.innerHeight - 100, vx: (Math.random()-0.5)*2, vy: -2, color: '#22d3ee', size: 4 });
            for(let i=0; i<5; i++) bots.push({ id: `g2_${i}`, group: 2, x: window.innerWidth/2, y: 100, vx: (Math.random()-0.5)*2, vy: 2, color: '#fb7185', size: 3 });
            for(let i=0; i<7; i++) { const angle = (i / 7) * Math.PI * 2; bots.push({ id: `g3_${i}`, group: 3, x: window.innerWidth/2, y: window.innerHeight/2, vx: Math.cos(angle)*1.5, vy: Math.sin(angle)*1.5, color: '#fbbf24', size: 3 }); }
            simState.current.bots = bots;
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const update = () => {
            const s = simState.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;

            if (Date.now() - s.lastSpawn > 1000 && s.zetaTargets.length < 30) {
                s.zetaTargets.push({ x: Math.random() * cw, y: Math.random() * ch, val: Math.floor(Math.random()*1000), consumed: false });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0;
                s.visitedNodes.forEach(node => {
                    const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                    if (distSq < 4000) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 0.5; repulseY += (dy/dist) * 0.5; }
                });

                let attractX = 0; let attractY = 0; let minDist = Infinity;
                s.zetaTargets.forEach((target) => {
                    if (target.consumed) return; // Ignore already eaten targets
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 100 && dist < minDist) { minDist = dist; attractX = dx/dist; attractY = dy/dist; }
                    // Mark as consumed instead of splicing array during iteration to prevent bugs
                    if (dist < 15) { target.consumed = true; } 
                });

                let dirX = 0; let dirY = 0;
                if (bot.group === 1) dirY = -0.5;
                if (bot.group === 2) dirY = 0.5;
                if (bot.group === 3) { dirX = (bot.x - cw/2) > 0 ? 0.2 : -0.2; dirY = (bot.y - ch/2) > 0 ? 0.2 : -0.2; }

                bot.vx += repulseX + attractX * 0.5 + dirX; bot.vy += repulseY + attractY * 0.5 + dirY;
                const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                if (speed > 3) { bot.vx = (bot.vx/speed)*3; bot.vy = (bot.vy/speed)*3; }

                bot.x += bot.vx; bot.y += bot.vy;
                if (bot.x < 0) { bot.x = 0; bot.vx *= -1; } if (bot.x > cw) { bot.x = cw; bot.vx *= -1; }
                if (bot.y < 0) { bot.y = 0; bot.vy *= -1; } if (bot.y > ch) { bot.y = ch; bot.vy *= -1; }

                if (Math.random() < 0.1) {
                    s.visitedNodes.push({x: bot.x, y: bot.y, age: 255});
                    if (s.visitedNodes.length > 200) s.visitedNodes.shift();
                }
            });

            // Filter out consumed targets safely at the end of the frame
            const initialTargetCount = s.zetaTargets.length;
            s.zetaTargets = s.zetaTargets.filter(t => !t.consumed);
            const targetsEatenThisFrame = initialTargetCount - s.zetaTargets.length;
            if (targetsEatenThisFrame > 0) {
                setZetaSorted(prev => prev + targetsEatenThisFrame);
            }

            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            ctx.fillStyle = 'rgba(15, 23, 42, 0.3)'; ctx.fillRect(0, 0, cw, ch);
            
            // Draw background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<cw; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,ch); }
            for(let y=0; y<ch; y+=50) { ctx.moveTo(0,y); ctx.lineTo(cw,y); }
            ctx.stroke();

            s.visitedNodes.forEach(node => {
                ctx.beginPath(); ctx.arc(node.x, node.y, 2, 0, Math.PI*2);
                ctx.fillStyle = `rgba(255, 255, 255, ${node.age/1000})`; ctx.fill();
            });

            s.zetaTargets.forEach(target => {
                ctx.beginPath(); ctx.rect(target.x-4, target.y-4, 8, 8);
                ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 1; ctx.stroke();
                ctx.fillStyle = 'rgba(74, 222, 128, 0.2)'; ctx.fill();
            });

            ctx.lineWidth = 0.5;
            for(let i=0; i<s.bots.length; i++) {
                for(let j=i+1; j<s.bots.length; j++) {
                    const b1 = s.bots[i]; const b2 = s.bots[j];
                    if (b1.group === b2.group) {
                        const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                        if (dx*dx + dy*dy < 20000) { ctx.beginPath(); ctx.moveTo(b1.x, b1.y); ctx.lineTo(b2.x, b2.y); ctx.strokeStyle = b1.color + '40'; ctx.stroke(); }
                    }
                }
            }

            s.bots.forEach(bot => {
                ctx.beginPath(); ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI*2);
                ctx.fillStyle = bot.color; ctx.shadowBlur = 10; ctx.shadowColor = bot.color; ctx.fill(); ctx.shadowBlur = 0;
            });

            if (isRunning) requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning]);

          return (
             <div className="flex-1 flex flex-col md:flex-row relative min-h-0 overflow-hidden">
                <aside className="w-full md:w-72 flex-shrink-0 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10 max-h-[45%] md:max-h-none">
                  <section className="space-y-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-emerald-400">Protocol</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-emerald-500'}`}>{isRunning ? 'Halt' : 'Resume'}</button>
                    </div>

                    <div className="p-4 bg-slate-800/50 rounded-xl border border-slate-700">
                        <div className="text-xs text-slate-400 uppercase font-bold mb-1">Zeta Numbers</div>
                        <div className="text-3xl font-mono text-emerald-400">{zetaSorted.toLocaleString()}</div>
                    </div>

                    <div className="space-y-3">
                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-cyan-500/20"><div className="w-3 h-3 rounded-full bg-cyan-400"></div><div><div className="text-sm font-bold text-slate-200">G1 (Upward)</div></div></div>
                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-rose-500/20"><div className="w-3 h-3 rounded-full bg-rose-400"></div><div><div className="text-sm font-bold text-slate-200">G2 (Downward)</div></div></div>
                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-amber-500/20"><div className="w-3 h-3 rounded-full bg-amber-400"></div><div><div className="text-sm font-bold text-slate-200">G3 (Radial)</div></div></div>
                    </div>
                  </section>
                </aside>
                <div className="flex-1 relative min-h-0 bg-slate-950">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                </div>
             </div>
          );
        };

        // ==========================================
        // TAB 3: MEDICAL APPLICATION (SIDE-BY-SIDE)
        // ==========================================
        const MedicalSim = () => {
          const canvasStandardRef = useRef(null);
          const canvasSwarmRef = useRef(null);
          const requestRef = useRef(null);
          
          const [stats, setStats] = useState({ standard: 0, swarm: 0 });
          const simState = useRef({ 
            standard: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0 },
            swarm: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0 }
          });

          useEffect(() => {
            const handleResize = () => {
              [canvasStandardRef.current, canvasSwarmRef.current].forEach(canvas => {
                if (canvas && canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; }
              });
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);

            const initBots = () => {
                const arr = [];
                for(let i=0; i<15; i++) arr.push({ x: window.innerWidth/4, y: window.innerHeight/4, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, color: '#f8fafc', size: 4 });
                return arr;
            };
            
            simState.current.standard.bots = initBots();
            simState.current.swarm.bots = initBots();

            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const updateEngine = (s, canvas, isSwarm) => {
            if (!canvas) return 0;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;
            let foundCount = 0;

            if (Date.now() - s.lastSpawn > 2000 && s.targets.length < 10) {
                s.targets.push({ x: Math.random() * cw, y: Math.random() * ch, consumed: false });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0;
                
                if (isSwarm) {
                    s.visitedNodes.forEach(node => {
                        const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 5000) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 0.8; repulseY += (dy/dist) * 0.8; }
                    });
                }

                let attractX = 0; let attractY = 0; let minDist = Infinity;
                s.targets.forEach((target) => {
                    if (target.consumed) return;
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    const detectionRadius = isSwarm ? 150 : 50; 
                    if (dist < detectionRadius && dist < minDist) { minDist = dist; attractX = dx/dist; attractY = dy/dist; }
                    if (dist < 20) { target.consumed = true; foundCount++; }
                });

                bot.vx += repulseX + attractX * 1.2 + (Math.random()-0.5)*0.5;
                bot.vy += repulseY + attractY * 1.2 + (Math.random()-0.5)*0.5;
                const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                if (speed > 2.5) { bot.vx = (bot.vx/speed)*2.5; bot.vy = (bot.vy/speed)*2.5; }

                bot.x += bot.vx; bot.y += bot.vy;
                if (bot.x < 0) { bot.x=0; bot.vx *= -1;} if (bot.x > cw) {bot.x=cw; bot.vx *= -1;}
                if (bot.y < 0) { bot.y=0; bot.vy *= -1;} if (bot.y > ch) {bot.y=ch; bot.vy *= -1;}

                if (Math.random() < 0.2) {
                    s.visitedNodes.push({x: bot.x, y: bot.y, age: 300});
                    if (s.visitedNodes.length > 300) s.visitedNodes.shift();
                }
            });

            s.targets = s.targets.filter(t => !t.consumed);
            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            ctx.fillStyle = 'rgba(76, 5, 25, 0.4)'; ctx.fillRect(0, 0, cw, ch);
            
            // Draw biological grid context
            ctx.strokeStyle = 'rgba(244, 114, 182, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<cw; x+=60) { ctx.moveTo(x,0); ctx.lineTo(x,ch); }
            for(let y=0; y<ch; y+=60) { ctx.moveTo(0,y); ctx.lineTo(cw,y); }
            ctx.stroke();

            s.visitedNodes.forEach(node => {
                ctx.beginPath(); ctx.arc(node.x, node.y, 4, 0, Math.PI*2);
                ctx.fillStyle = `rgba(244, 114, 182, ${node.age/1500})`; ctx.fill();
            });

            s.targets.forEach(target => {
                ctx.beginPath(); ctx.arc(target.x, target.y, 8, 0, Math.PI*2);
                ctx.fillStyle = '#fef08a'; ctx.shadowBlur = 15; ctx.shadowColor = '#eab308'; ctx.fill(); ctx.shadowBlur = 0;
            });

            s.bots.forEach(bot => {
                ctx.beginPath(); ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI*2);
                ctx.fillStyle = bot.color; ctx.fill();
            });

            return foundCount;
          };

          const update = () => {
             const foundStd = updateEngine(simState.current.standard, canvasStandardRef.current, false);
             const foundSwm = updateEngine(simState.current.swarm, canvasSwarmRef.current, true);
             
             if (foundStd > 0 || foundSwm > 0) {
                 setStats(prev => ({ standard: prev.standard + foundStd, swarm: prev.swarm + foundSwm }));
             }
             requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => { requestRef.current = requestAnimationFrame(update); return () => cancelAnimationFrame(requestRef.current); }, []);

          return (
             <div className="flex-1 flex flex-col xl:flex-row relative min-h-0 bg-slate-950 overflow-hidden">
                <aside className="w-full xl:w-72 flex-shrink-0 bg-rose-950/40 border-b xl:border-b-0 xl:border-r border-rose-900/50 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10 max-h-[45%] md:max-h-none">
                  <section className="space-y-6">
                    <div className="flex items-center gap-2 mb-4">
                        <HeartPulse size={20} className="text-rose-400" />
                        <h2 className="text-sm font-bold uppercase tracking-wider text-rose-400">Medical Setup</h2>
                    </div>
                    <div className="p-4 bg-rose-900/20 rounded-xl border border-rose-500/30">
                        <div className="text-sm text-slate-200 font-bold mb-2">A/B Comparison</div>
                        <p className="text-xs text-slate-400 leading-relaxed">
                            Watch the left simulation blindly wander (Standard/Random). Watch the right simulation efficiently map and clear the tissue using shared memory.
                        </p>
                    </div>
                    
                    <div className="grid grid-cols-2 gap-2">
                        <div className="p-3 bg-slate-900/50 rounded-xl border border-slate-700">
                            <div className="text-[10px] text-slate-400 uppercase font-bold mb-1">Standard Hits</div>
                            <div className="text-xl font-mono text-white">{stats.standard}</div>
                        </div>
                        <div className="p-3 bg-rose-900/50 rounded-xl border border-rose-500/50">
                            <div className="text-[10px] text-rose-300 uppercase font-bold mb-1">Swarm Hits</div>
                            <div className="text-xl font-mono text-white">{stats.swarm}</div>
                        </div>
                    </div>
                  </section>
                </aside>
                
                <div className="flex-1 flex flex-col md:flex-row relative min-h-0">
                    <div className="flex-1 relative min-h-[50%] md:min-h-0 border-b md:border-b-0 md:border-r border-rose-900/50">
                        <canvas ref={canvasStandardRef} className="absolute inset-0 w-full h-full block bg-[#1a050f]" />
                        <div className="absolute top-4 left-4 bg-slate-900/80 px-3 py-1.5 rounded-lg border border-slate-700 backdrop-blur-sm">
                            <span className="text-xs font-bold text-slate-300 uppercase tracking-widest">Standard</span>
                        </div>
                    </div>
                    <div className="flex-1 relative min-h-[50%] md:min-h-0">
                        <canvas ref={canvasSwarmRef} className="absolute inset-0 w-full h-full block bg-[#1a050f]" />
                        <div className="absolute top-4 left-4 bg-rose-900/80 px-3 py-1.5 rounded-lg border border-rose-700 backdrop-blur-sm">
                            <span className="text-xs font-bold text-rose-300 uppercase tracking-widest">Smith/Blade</span>
                        </div>
                    </div>
                </div>
             </div>
          );
        };

        // ==========================================
        // TAB 4: TECH/DEEP LEARNING (SIDE-BY-SIDE)
        // ==========================================
        const TechSim = () => {
          const canvasStandardRef = useRef(null);
          const canvasSwarmRef = useRef(null);
          const requestRef = useRef(null);
          
          const [stats, setStats] = useState({ standard: 0, swarm: 0 });
          const simState = useRef({ 
            standard: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0 },
            swarm: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0 }
          });

          useEffect(() => {
            const handleResize = () => {
              [canvasStandardRef.current, canvasSwarmRef.current].forEach(canvas => {
                if (canvas && canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; }
              });
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);

            const initBots = () => {
                const arr = [];
                for(let i=0; i<20; i++) arr.push({ x: window.innerWidth/4, y: window.innerHeight/4, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, color: '#38bdf8', size: 3 });
                return arr;
            };
            
            simState.current.standard.bots = initBots();
            simState.current.swarm.bots = initBots();

            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const updateEngine = (s, canvas, isSwarm) => {
            if (!canvas) return 0;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;
            let foundCount = 0;

            if (Date.now() - s.lastSpawn > 1500 && s.targets.length < 15) {
                s.targets.push({ x: Math.floor(Math.random() * (cw/40))*40, y: Math.floor(Math.random() * (ch/40))*40, consumed: false });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0;
                
                if (isSwarm) {
                    s.visitedNodes.forEach(node => {
                        const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 3000) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 1.5; repulseY += (dy/dist) * 1.5; }
                    });
                }

                let attractX = 0; let attractY = 0; let minDist = Infinity;
                s.targets.forEach((target) => {
                    if (target.consumed) return;
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    const detection = isSwarm ? 200 : 80;
                    if (dist < detection && dist < minDist) { minDist = dist; attractX = dx/dist; attractY = dy/dist; }
                    if (dist < 15) { target.consumed = true; foundCount++; }
                });

                if (Math.random() > 0.8) { if (Math.abs(bot.vx) > Math.abs(bot.vy)) bot.vy = 0; else bot.vx = 0; }

                bot.vx += repulseX + attractX; bot.vy += repulseY + attractY;
                const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                if (speed > 4) { bot.vx = (bot.vx/speed)*4; bot.vy = (bot.vy/speed)*4; }

                bot.x += bot.vx; bot.y += bot.vy;
                if (bot.x < 0) {bot.x=0; bot.vx *= -1;} if (bot.x > cw) {bot.x=cw; bot.vx *= -1;}
                if (bot.y < 0) {bot.y=0; bot.vy *= -1;} if (bot.y > ch) {bot.y=ch; bot.vy *= -1;}

                if (Math.random() < 0.3) {
                    s.visitedNodes.push({x: bot.x, y: bot.y, age: 100});
                    if (s.visitedNodes.length > 150) s.visitedNodes.shift();
                }
            });

            s.targets = s.targets.filter(t => !t.consumed);
            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            ctx.fillStyle = 'rgba(2, 6, 23, 0.5)'; ctx.fillRect(0, 0, cw, ch);
            ctx.strokeStyle = 'rgba(56, 189, 248, 0.05)'; ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<cw; i+=40) { ctx.moveTo(i, 0); ctx.lineTo(i, ch); }
            for(let i=0; i<ch; i+=40) { ctx.moveTo(0, i); ctx.lineTo(cw, i); }
            ctx.stroke();

            s.visitedNodes.forEach(node => {
                ctx.beginPath(); ctx.rect(node.x-2, node.y-2, 4, 4);
                ctx.fillStyle = `rgba(56, 189, 248, ${node.age/200})`; ctx.fill(); 
            });

            s.targets.forEach(target => {
                ctx.beginPath(); ctx.arc(target.x, target.y, 6, 0, Math.PI*2);
                ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = 'rgba(244, 63, 94, 0.2)'; ctx.fill();
            });

            if (isSwarm) {
                ctx.lineWidth = 0.5;
                for(let i=0; i<s.bots.length; i++) {
                    for(let j=i+1; j<s.bots.length; j++) {
                        const b1 = s.bots[i]; const b2 = s.bots[j];
                        const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                        if (dx*dx + dy*dy < 10000) { 
                            ctx.beginPath(); ctx.moveTo(b1.x, b1.y); ctx.lineTo(b1.x, b2.y); ctx.lineTo(b2.x, b2.y); 
                            ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)'; ctx.stroke(); 
                        }
                    }
                }
            }

            s.bots.forEach(bot => { ctx.beginPath(); ctx.rect(bot.x-bot.size, bot.y-bot.size, bot.size*2, bot.size*2); ctx.fillStyle = bot.color; ctx.fill(); });
            
            return foundCount;
          };

          const update = () => {
             const foundStd = updateEngine(simState.current.standard, canvasStandardRef.current, false);
             const foundSwm = updateEngine(simState.current.swarm, canvasSwarmRef.current, true);
             if (foundStd > 0 || foundSwm > 0) setStats(prev => ({ standard: prev.standard + foundStd, swarm: prev.swarm + foundSwm }));
             requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => { requestRef.current = requestAnimationFrame(update); return () => cancelAnimationFrame(requestRef.current); }, []);

          return (
             <div className="flex-1 flex flex-col xl:flex-row relative min-h-0 bg-slate-950 overflow-hidden">
                <aside className="w-full xl:w-72 flex-shrink-0 bg-slate-900/80 border-b xl:border-b-0 xl:border-r border-sky-900/50 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10 max-h-[45%] md:max-h-none">
                  <section className="space-y-6">
                    <div className="flex items-center gap-2 mb-4">
                        <CpuIcon size={20} className="text-sky-400" />
                        <h2 className="text-sm font-bold uppercase tracking-wider text-sky-400">Deep Learning App</h2>
                    </div>
                    <div className="p-4 bg-slate-800/80 rounded-xl border border-sky-500/30">
                        <div className="text-sm text-slate-200 font-bold mb-2">A/B Testing</div>
                        <p className="text-xs text-slate-400 leading-relaxed mb-4">
                            Left: Standard algorithms frequently get trapped in "local minima" (loops). Right: Holographic Swarm maps failures and actively repels, finding the "global minima" much faster.
                        </p>
                    </div>
                    <div className="grid grid-cols-2 gap-2">
                        <div className="p-3 bg-slate-900/50 rounded-xl border border-slate-700">
                            <div className="text-[10px] text-slate-400 uppercase font-bold mb-1">Standard GD</div>
                            <div className="text-xl font-mono text-white">{stats.standard}</div>
                        </div>
                        <div className="p-3 bg-sky-900/50 rounded-xl border border-sky-500/50">
                            <div className="text-[10px] text-sky-300 uppercase font-bold mb-1">Holo Swarm</div>
                            <div className="text-xl font-mono text-white">{stats.swarm}</div>
                        </div>
                    </div>
                  </section>
                </aside>
                
                <div className="flex-1 flex flex-col md:flex-row relative min-h-0">
                    <div className="flex-1 relative min-h-[50%] md:min-h-0 border-b md:border-b-0 md:border-r border-slate-800">
                        <canvas ref={canvasStandardRef} className="absolute inset-0 w-full h-full block bg-[#020617]" />
                        <div className="absolute top-4 left-4 bg-slate-900/80 px-3 py-1.5 rounded-lg border border-slate-700 backdrop-blur-sm">
                            <span className="text-xs font-bold text-slate-300 uppercase tracking-widest">Standard Descend</span>
                        </div>
                    </div>
                    <div className="flex-1 relative min-h-[50%] md:min-h-0">
                        <canvas ref={canvasSwarmRef} className="absolute inset-0 w-full h-full block bg-[#020617]" />
                        <div className="absolute top-4 left-4 bg-sky-900/80 px-3 py-1.5 rounded-lg border border-sky-700 backdrop-blur-sm">
                            <span className="text-xs font-bold text-sky-300 uppercase tracking-widest">Swarm Optimization</span>
                        </div>
                    </div>
                </div>
             </div>
          );
        };

        // ==========================================
        // MAIN APP CONTAINER
        // ==========================================
        const App = () => {
          const [activeTab, setActiveTab] = useState(1);

          return (
            <div className="flex flex-col h-[100dvh] bg-slate-950 text-slate-100 font-sans overflow-hidden">
              <header className="flex flex-col md:flex-row items-start md:items-center justify-between px-4 md:px-6 py-3 bg-slate-900/80 border-b border-slate-800 backdrop-blur-md z-20 gap-4 shadow-xl">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-indigo-500/20 rounded-lg text-indigo-400">
                    <Activity size={24} />
                  </div>
                  <div>
                    <h1 className="text-lg md:text-xl font-bold tracking-tight">Project Genesis</h1>
                    <p className="text-[10px] md:text-xs text-slate-400 uppercase tracking-widest font-medium">Multi-Disciplinary Simulations</p>
                  </div>
                </div>

                <div className="flex w-full md:w-auto overflow-x-auto pb-2 md:pb-0 scrollbar-hide">
                    <div className="flex bg-slate-800/50 p-1 rounded-xl min-w-max">
                        <button onClick={() => setActiveTab(1)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 1 ? 'bg-indigo-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <BoxIcon size={16} /> <span className="hidden sm:inline">Billiard</span> Inversion
                        </button>
                        <button onClick={() => setActiveTab(2)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 2 ? 'bg-emerald-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <NetworkIcon size={16} /> Zeta Swarm
                        </button>
                        <button onClick={() => setActiveTab(3)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 3 ? 'bg-rose-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <HeartPulse size={16} /> Medicine (A/B)
                        </button>
                        <button onClick={() => setActiveTab(4)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 4 ? 'bg-sky-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <CpuIcon size={16} /> Tech / DL (A/B)
                        </button>
                    </div>
                </div>
              </header>

              <main className="flex-1 flex flex-col relative min-h-0 overflow-hidden">
                {activeTab === 1 && <BilliardSim />}
                {activeTab === 2 && <ZetaSwarmSim />}
                {activeTab === 3 && <MedicalSim />}
                {activeTab === 4 && <TechSim />}
              </main>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <style>
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</body>
</html>