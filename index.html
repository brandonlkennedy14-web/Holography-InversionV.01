<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Genesis: Holography & Swarm Logic</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- Load Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-950 text-slate-100 font-sans overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Inline Icons ---
        const Activity = ({size=24}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>;
        const Play = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const Pause = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const RefreshCw = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;
        const BoxIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const NetworkIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>;
        const HeartPulse = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"></path><path d="M3.22 12H9.5l.5-1 2 4.5 2-7 1.5 3.5h5.27"></path></svg>;
        const CpuIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>;

        // ==========================================
        // TAB 1: BILLIARD INVERSION (RESPONSIVE)
        // ==========================================
        const BilliardSim = () => {
          const [isRunning, setIsRunning] = useState(false);
          const [inversionRadius, setInversionRadius] = useState(100);
          const [speed, setSpeed] = useState(2);
          const [showInversionCircle, setShowInversionCircle] = useState(true);
          const [showDynamicGrid, setShowDynamicGrid] = useState(true);
          
          const [windingNumber, setWindingNumber] = useState(0);
          const [cornerHits, setCornerHits] = useState(0);
          const [configsRegistered, setConfigsRegistered] = useState(0);

          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const stateRef = useRef({ 
            pos: { x: null, y: null }, vel: { x: 1.8, y: 1.3 }, 
            stdPath: [], invPath: [], gridPhase: 0,
            winding: 0, corners: 0, configs: 0 
          });

          useEffect(() => {
            const saved = JSON.parse(localStorage.getItem('genesis_billiard') || '{}');
            stateRef.current.winding = saved.winding || 0;
            stateRef.current.corners = saved.corners || 0;
            stateRef.current.configs = saved.configs || 0;
            
            const syncInterval = setInterval(() => {
                setWindingNumber(stateRef.current.winding);
                setCornerHits(stateRef.current.corners);
                setConfigsRegistered(stateRef.current.configs);
                localStorage.setItem('genesis_billiard', JSON.stringify({ winding: stateRef.current.winding, corners: stateRef.current.corners, configs: stateRef.current.configs }));
            }, 500);
            return () => clearInterval(syncInterval);
          }, []);

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              if (canvas.parentElement) { 
                canvas.width = canvas.parentElement.clientWidth; 
                canvas.height = canvas.parentElement.clientHeight; 
                if (!stateRef.current.pos.x) {
                  stateRef.current.pos = { x: canvas.width/2, y: canvas.height/2 };
                }
              }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100); 
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const invertPoint = (x, y, cx, cy, r) => {
            const dx = x - cx; const dy = y - cy; const distSq = dx * dx + dy * dy;
            if (distSq === 0) return { x, y };
            const factor = (r * r) / distSq;
            return { x: cx + dx * factor, y: cy + dy * factor };
          };

          const update = () => {
            const s = stateRef.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const cw = canvas.width; const ch = canvas.height;
            const cx = cw / 2; const cy = ch / 2; 
            
            const boundSize = Math.min(cw, ch) * 0.55; 
            const halfSize = boundSize / 2;
            const trailLength = 3000;

            if (s.pos.x === null) s.pos = { x: cx, y: cy };

            for (let i = 0; i < speed; i++) {
              s.pos.x += s.vel.x; s.pos.y += s.vel.y;
              
              const left = cx - halfSize; const right = cx + halfSize; 
              const top = cy - halfSize; const bottom = cy + halfSize;
              let hitCornerX = false; let hitCornerY = false;

              if (s.pos.x <= left) { s.vel.x *= -1; s.pos.x = left + 1; hitCornerX = Math.abs(s.pos.y - top) < 15 || Math.abs(s.pos.y - bottom) < 15; }
              else if (s.pos.x >= right) { s.vel.x *= -1; s.pos.x = right - 1; hitCornerX = Math.abs(s.pos.y - top) < 15 || Math.abs(s.pos.y - bottom) < 15; }
              
              if (s.pos.y <= top) { s.vel.y *= -1; s.pos.y = top + 1; hitCornerY = Math.abs(s.pos.x - left) < 15 || Math.abs(s.pos.x - right) < 15; }
              else if (s.pos.y >= bottom) { s.vel.y *= -1; s.pos.y = bottom - 1; hitCornerY = Math.abs(s.pos.x - left) < 15 || Math.abs(s.pos.x - right) < 15; }

              if (hitCornerX || hitCornerY) {
                s.corners += 1;
                s.winding += (s.vel.x * s.vel.y > 0 ? 1 : -1);
              }

              s.stdPath.push({x: s.pos.x, y: s.pos.y});
              if (s.stdPath.length > trailLength) s.stdPath.shift();

              const inverted = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
              s.invPath.push(inverted);
              if (s.invPath.length > trailLength) s.invPath.shift();
            }

            s.gridPhase += 0.05 * speed;
            s.configs += Math.floor(speed * 4); 

            ctx.clearRect(0, 0, cw, ch);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1; ctx.beginPath();
            for(let x=0; x<cw; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,ch); }
            for(let y=0; y<ch; y+=50) { ctx.moveTo(0,y); ctx.lineTo(cw,y); }
            ctx.stroke();

            if (showDynamicGrid) {
              ctx.strokeStyle = 'rgba(56, 189, 248, 0.15)'; 
              ctx.lineWidth = 1; ctx.beginPath();
              const phaseOffset = Math.sin(s.gridPhase) * 20;
              for(let i = -halfSize; i <= halfSize; i+=30) {
                  let x = cx + i + phaseOffset;
                  if (x > cx - halfSize && x < cx + halfSize) { ctx.moveTo(x, cy - halfSize); ctx.lineTo(x, cy + halfSize); }
                  let y = cy + i + Math.cos(s.gridPhase) * 20;
                  if (y > cy - halfSize && y < cy + halfSize) { ctx.moveTo(cx - halfSize, y); ctx.lineTo(cx + halfSize, y); }
              }
              ctx.stroke();
            }

            if (showInversionCircle) {
              ctx.beginPath(); ctx.arc(cx, cy, inversionRadius, 0, Math.PI * 2);
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }

            ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)';
            ctx.strokeRect(cx - halfSize, cy - halfSize, boundSize, boundSize);

            if (s.stdPath.length > 1) {
              ctx.beginPath(); ctx.moveTo(s.stdPath[0].x, s.stdPath[0].y);
              for (let i = 1; i < s.stdPath.length; i++) ctx.lineTo(s.stdPath[i].x, s.stdPath[i].y);
              ctx.strokeStyle = 'rgba(56, 189, 248, 0.5)'; ctx.lineWidth = 1; ctx.stroke();
            }

            if (s.invPath.length > 1) {
              ctx.beginPath(); ctx.moveTo(s.invPath[0].x, s.invPath[0].y);
              for (let i = 1; i < s.invPath.length; i++) ctx.lineTo(s.invPath[i].x, s.invPath[i].y);
              const gradient = ctx.createRadialGradient(cx, cy, 10, cx, cy, inversionRadius * 2);
              gradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)'); gradient.addColorStop(1, 'rgba(236, 72, 153, 0.1)');
              ctx.strokeStyle = gradient; ctx.lineWidth = 1.5; ctx.stroke();
            }

            ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#38bdf8'; ctx.fill(); 

            const currentInv = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
            ctx.beginPath(); ctx.arc(currentInv.x, currentInv.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#f472b6'; ctx.shadowBlur = 10; ctx.shadowColor = '#f472b6'; ctx.fill(); ctx.shadowBlur = 0;

            requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning, speed, inversionRadius, showDynamicGrid]);

          const handleReset = () => {
             stateRef.current.stdPath = []; stateRef.current.invPath = []; 
             stateRef.current.winding = 0; stateRef.current.corners = 0; stateRef.current.configs = 0;
             setWindingNumber(0); setCornerHits(0); setConfigsRegistered(0);
             localStorage.setItem('genesis_billiard', JSON.stringify({ winding: 0, corners: 0, configs: 0 }));
          };

          return (
            <div className="flex-1 flex flex-col md:flex-row relative min-h-0 overflow-hidden">
                <aside className="w-full md:w-72 flex-shrink-0 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 overflow-y-auto backdrop-blur-sm z-10 max-h-[35%] md:max-h-none">
                  <section className="space-y-4">
                    <div className="flex justify-between items-center mb-2">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-indigo-400">Controls</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-indigo-500'}`}>{isRunning ? 'Pause' : 'Start'}</button>
                    </div>
                    <div className="space-y-4">
                        <div className="space-y-1">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Inversion Radius</label><span className="text-indigo-400 font-mono">{inversionRadius}px</span></div>
                          <input type="range" min="30" max="250" value={inversionRadius} onChange={(e) => setInversionRadius(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                        <div className="space-y-1">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Speed</label><span className="text-indigo-400 font-mono">x{speed}</span></div>
                          <input type="range" min="1" max="10" value={speed} onChange={(e) => setSpeed(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                    </div>
                    <div className="pt-2 border-t border-slate-800 space-y-2">
                        <label className="flex items-center justify-between p-2 bg-slate-800/30 rounded-xl cursor-pointer hover:bg-slate-800/50">
                          <span className="text-xs font-medium">Dual Geometry Mesh</span>
                          <input type="checkbox" checked={showDynamicGrid} onChange={() => setShowDynamicGrid(!showDynamicGrid)} className="w-4 h-4 rounded accent-indigo-500" />
                        </label>
                        <button onClick={handleReset} className="w-full flex items-center justify-center gap-2 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800 text-slate-300 font-semibold text-xs">
                          <RefreshCw size={12} /> Reset Data
                        </button>
                    </div>
                  </section>
                </aside>
                <div className="flex-1 relative min-h-0 bg-[radial-gradient(circle_at_center,_#111827_0%,_#020617_100%)] overflow-hidden">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                  <div className="absolute bottom-4 left-4 right-4 flex justify-between items-end pointer-events-none">
                    <div className="bg-slate-900/90 backdrop-blur-md border border-slate-700 p-3 rounded-xl min-w-[200px] shadow-2xl">
                      <div className="flex justify-between text-xs mb-1"><span className="text-slate-500">Free Configs</span><span className="text-sky-400 font-mono">{configsRegistered.toLocaleString()}</span></div>
                      <div className="flex justify-between text-xs mb-1"><span className="text-slate-500">Winding</span><span className="text-emerald-400 font-mono">{windingNumber}</span></div>
                      <div className="flex justify-between text-xs"><span className="text-slate-500">Corners</span><span className="text-amber-400 font-mono">{cornerHits}</span></div>
                    </div>
                  </div>
                </div>
            </div>
          );
        };

        // ==========================================
        // TAB 2: ZETA SWARM (SMITH & BLADE LOGIC)
        // ==========================================
        const ZetaSwarmSim = () => {
          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const [zetaSorted, setZetaSorted] = useState(0);
          const [isRunning, setIsRunning] = useState(true);
          const [dataLog, setDataLog] = useState([]);
          
          const simState = useRef({ 
            bots: [], visitedNodes: [], zetaTargets: [], 
            lastSpawn: 0, zetaCount: 0, initialized: false,
            newLogs: [] 
          });

          useEffect(() => {
            const saved = JSON.parse(localStorage.getItem('genesis_zeta') || '{}');
            simState.current.zetaCount = saved.count || 0;
            const syncInterval = setInterval(() => {
                setZetaSorted(simState.current.zetaCount);
                localStorage.setItem('genesis_zeta', JSON.stringify({ count: simState.current.zetaCount }));
                
                if (simState.current.newLogs.length > 0) {
                    setDataLog(prev => {
                        const updated = [...simState.current.newLogs, ...prev];
                        return updated.slice(0, 6); 
                    });
                    simState.current.newLogs = [];
                }
            }, 500);
            return () => clearInterval(syncInterval);
          }, []);

          useEffect(() => {
            const handleResize = () => { if (canvasRef.current && canvasRef.current.parentElement) { canvasRef.current.width = canvasRef.current.parentElement.clientWidth; canvasRef.current.height = canvasRef.current.parentElement.clientHeight; } };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const update = () => {
            const s = simState.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;

            if (!s.initialized && cw > 0 && ch > 0) {
                s.bots = [];
                for(let i=0; i<7; i++) { 
                    const angle = (i/7) * Math.PI * 2;
                    s.bots.push({ group: 3, x: cw/2, y: ch/2, vx: Math.cos(angle)*3, vy: Math.sin(angle)*3, color: '#22d3ee', size: 4 }); 
                }
                s.initialized = true;
            }

            if (s.initialized) {
                if (Date.now() - s.lastSpawn > 800 && s.zetaTargets.length < 25) {
                    s.zetaTargets.push({ x: 20 + Math.random()*(cw-40), y: 20 + Math.random()*(ch-40), consumed: false });
                    s.lastSpawn = Date.now();
                }

                s.bots.forEach(bot => {
                    let repulseX = 0; let repulseY = 0;
                    s.visitedNodes.forEach(node => {
                        const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 2500 && distSq > 0.1) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 0.3; repulseY += (dy/dist) * 0.3; }
                    });

                    let attractX = 0; let attractY = 0; let minDist = Infinity;
                    s.zetaTargets.forEach((target) => {
                        if (target.consumed) return; 
                        const dx = target.x - bot.x; const dy = target.y - bot.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 90000 && distSq < minDist) { minDist = distSq; const dist = Math.sqrt(distSq); attractX = (dx/dist) * 1.5; attractY = (dy/dist) * 1.5; }
                        if (distSq < 400) { 
                            target.consumed = true; 
                            s.zetaCount += 1; 
                            const simulatedT = (14.134725 + (Math.random() * 100)).toFixed(5);
                            s.newLogs.push({ id: Math.random().toString(), text: `ζ(½ + ${simulatedT}i) verified` });
                        } 
                    });

                    if (bot.x < 20) bot.vx += 0.5; if (bot.x > cw - 20) bot.vx -= 0.5;
                    if (bot.y < 20) bot.vy += 0.5; if (bot.y > ch - 20) bot.vy -= 0.5;

                    bot.vx += repulseX + attractX + (Math.random()-0.5)*0.5; 
                    bot.vy += repulseY + attractY + (Math.random()-0.5)*0.5;
                    const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                    if (speed > 4.5) { bot.vx = (bot.vx/speed)*4.5; bot.vy = (bot.vy/speed)*4.5; }

                    bot.x += bot.vx; bot.y += bot.vy;
                    if (bot.x < 0) { bot.x = 0; bot.vx *= -1; } if (bot.x > cw) { bot.x = cw; bot.vx *= -1; }
                    if (bot.y < 0) { bot.y = 0; bot.vy *= -1; } if (bot.y > ch) { bot.y = ch; bot.vy *= -1; }

                    if (Math.random() < 0.15) { s.visitedNodes.push({x: bot.x, y: bot.y, age: 150}); if (s.visitedNodes.length > 200) s.visitedNodes.shift(); }
                });

                s.zetaTargets = s.zetaTargets.filter(t => !t.consumed);
                s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);
            }

            ctx.fillStyle = 'rgba(15, 23, 42, 0.4)'; ctx.fillRect(0, 0, cw, ch);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)'; ctx.lineWidth = 1; ctx.beginPath();
            for(let x=0; x<cw; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,ch); }
            for(let y=0; y<ch; y+=50) { ctx.moveTo(0,y); ctx.lineTo(cw,y); }
            ctx.stroke();

            s.visitedNodes.forEach(node => { ctx.beginPath(); ctx.arc(node.x, node.y, 2, 0, Math.PI*2); ctx.fillStyle = `rgba(255, 255, 255, ${node.age/1000})`; ctx.fill(); });
            
            s.zetaTargets.forEach(target => {
                ctx.beginPath(); ctx.rect(target.x-5, target.y-5, 10, 10);
                ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = 'rgba(74, 222, 128, 0.3)'; ctx.fill();
            });

            ctx.lineWidth = 0.5;
            for(let i=0; i<s.bots.length; i++) {
                for(let j=i+1; j<s.bots.length; j++) {
                    const b1 = s.bots[i]; const b2 = s.bots[j];
                    const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                    if (dx*dx + dy*dy < 20000) { ctx.beginPath(); ctx.moveTo(b1.x, b1.y); ctx.lineTo(b2.x, b2.y); ctx.strokeStyle = '#22d3ee50'; ctx.stroke(); }
                }
            }

            s.bots.forEach(bot => { ctx.beginPath(); ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI*2); ctx.fillStyle = bot.color; ctx.shadowBlur = 10; ctx.shadowColor = bot.color; ctx.fill(); ctx.shadowBlur = 0; });
            if (isRunning) requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning]);

          const handleReset = () => {
             simState.current.zetaCount = 0;
             simState.current.newLogs = [];
             setZetaSorted(0);
             setDataLog([]);
             localStorage.setItem('genesis_zeta', JSON.stringify({ count: 0 }));
          };

          return (
             <div className="flex-1 flex flex-col md:flex-row relative min-h-0 overflow-hidden">
                <aside className="w-full md:w-72 flex-shrink-0 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 overflow-y-auto backdrop-blur-sm z-10 max-h-[45%] md:max-h-none flex flex-col">
                  <section className="space-y-4 flex-1">
                    <div className="flex justify-between items-center mb-2">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-emerald-400">Protocol</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-emerald-500'}`}>{isRunning ? 'Halt' : 'Resume'}</button>
                    </div>

                    <div className="p-4 bg-slate-800/80 rounded-xl border border-slate-600 shadow-lg">
                        <div className="text-xs text-slate-400 uppercase font-bold mb-1">Zeta Targets Mapped</div>
                        <div className="text-3xl font-mono text-emerald-400">{zetaSorted.toLocaleString()}</div>
                    </div>

                    <div className="p-3 bg-slate-900 border border-slate-700 rounded-xl shadow-inner flex-1 flex flex-col min-h-[120px]">
                        <div className="text-[10px] text-slate-500 uppercase font-bold mb-2">Live Data Terminal</div>
                        <div className="font-mono text-[10px] text-sky-400/80 space-y-1 overflow-hidden flex flex-col justify-end flex-1">
                            {dataLog.map((log, i) => (
                                <div key={log.id} className={`truncate ${i === 0 ? 'text-sky-300 font-bold' : ''}`}>
                                    > {log.text}
                                </div>
                            ))}
                            {dataLog.length === 0 && <div className="text-slate-600 italic">Waiting for target consumption...</div>}
                        </div>
                    </div>
                  </section>
                  <div className="pt-4 mt-auto">
                      <button onClick={handleReset} className="w-full flex items-center justify-center gap-2 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-slate-400 font-semibold text-xs transition-colors">
                          <RefreshCw size={12} /> Reset Ledger
                      </button>
                  </div>
                </aside>
                <div className="flex-1 relative min-h-0 bg-slate-950 overflow-hidden">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                </div>
             </div>
          );
        };

        // ==========================================
        // TAB 3: MEDICAL APPLICATION (OBSTACLE MAZE)
        // ==========================================
        const MedicalSim = () => {
          const canvasStandardRef = useRef(null);
          const canvasSwarmRef = useRef(null);
          const requestRef = useRef(null);
          
          const [stats, setStats] = useState({ standard: 0, swarm: 0 });
          const simState = useRef({ 
            standard: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0, hits: 0, init: false },
            swarm: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0, hits: 0, init: false }
          });

          useEffect(() => {
            const saved = JSON.parse(localStorage.getItem('genesis_medical') || '{}');
            simState.current.standard.hits = saved.standard || 0;
            simState.current.swarm.hits = saved.swarm || 0;
            const syncInterval = setInterval(() => {
                setStats({ standard: simState.current.standard.hits, swarm: simState.current.swarm.hits });
                localStorage.setItem('genesis_medical', JSON.stringify({ standard: simState.current.standard.hits, swarm: simState.current.swarm.hits }));
            }, 500);
            return () => clearInterval(syncInterval);
          }, []);

          useEffect(() => {
            const handleResize = () => {
              [canvasStandardRef.current, canvasSwarmRef.current].forEach(canvas => {
                if (canvas && canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; }
              });
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const updateEngine = (s, canvas, isSwarm) => {
            if (!canvas) return;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;

            // Define Medical "Tissue/Vein" Obstacles
            const obstacles = [
                { x: cw * 0.2, y: 0, w: Math.max(20, cw * 0.1), h: ch * 0.5 }, 
                { x: cw * 0.7, y: ch * 0.5, w: Math.max(20, cw * 0.1), h: ch * 0.5 },
                { x: cw * 0.4, y: ch * 0.3, w: Math.max(20, cw * 0.15), h: ch * 0.4 } 
            ];

            if (!s.init && cw > 0 && ch > 0) {
                s.bots = [];
                for(let i=0; i<15; i++) s.bots.push({ x: cw/2, y: ch/2, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, color: isSwarm ? '#34d399' : '#fb923c', size: 4 });
                s.init = true;
            }
            if (!s.init) return;

            // Spawn Targets explicitly in far corners
            if (Date.now() - s.lastSpawn > 1500 && s.targets.length < 15) {
                const corners = [
                    { x: cw * 0.1, y: ch * 0.1 }, { x: cw * 0.9, y: ch * 0.1 },
                    { x: cw * 0.1, y: ch * 0.9 }, { x: cw * 0.9, y: ch * 0.9 }
                ];
                const corner = corners[Math.floor(Math.random() * corners.length)];
                s.targets.push({ 
                    x: corner.x + (Math.random()-0.5)*cw*0.1, 
                    y: corner.y + (Math.random()-0.5)*ch*0.1, 
                    consumed: false 
                });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0;
                let attractX = 0; let attractY = 0; let minDist = Infinity;
                
                if (isSwarm) {
                    s.visitedNodes.forEach(node => {
                        const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 2500 && distSq > 0.1) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 0.4; repulseY += (dy/dist) * 0.4; }
                    });
                    
                    s.targets.forEach((target) => {
                        if (target.consumed) return;
                        const dx = target.x - bot.x; const dy = target.y - bot.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 60000 && distSq < minDist) { minDist = distSq; const dist = Math.sqrt(distSq); attractX = (dx/dist) * 3.0; attractY = (dy/dist) * 3.0; }
                    });
                }

                s.targets.forEach((target) => {
                    if (target.consumed) return;
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const distSq = dx*dx + dy*dy;
                    if (distSq < 400) { target.consumed = true; s.hits += 1; }
                });

                if (isSwarm) {
                    bot.vx += repulseX + attractX + (Math.random()-0.5)*0.5;
                    bot.vy += repulseY + attractY + (Math.random()-0.5)*0.5;
                    const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                    if (speed > 5.0) { bot.vx = (bot.vx/speed)*5.0; bot.vy = (bot.vy/speed)*5.0; }
                } else {
                    bot.vx += (Math.random()-0.5) * 1.5; bot.vy += (Math.random()-0.5) * 1.5;
                    bot.vx *= 0.95; bot.vy *= 0.95; 
                }

                // X Axis Movement & Collision
                bot.x += bot.vx;
                if (bot.x < 0) { bot.x=0; bot.vx *= -1;} if (bot.x > cw) {bot.x=cw; bot.vx *= -1;}
                obstacles.forEach(obs => {
                    if (bot.x > obs.x && bot.x < obs.x + obs.w && bot.y > obs.y && bot.y < obs.y + obs.h) {
                        bot.x -= bot.vx; bot.vx *= -1;
                    }
                });

                // Y Axis Movement & Collision
                bot.y += bot.vy;
                if (bot.y < 0) { bot.y=0; bot.vy *= -1;} if (bot.y > ch) {bot.y=ch; bot.vy *= -1;}
                obstacles.forEach(obs => {
                    if (bot.x > obs.x && bot.x < obs.x + obs.w && bot.y > obs.y && bot.y < obs.y + obs.h) {
                        bot.y -= bot.vy; bot.vy *= -1;
                    }
                });

                if (isSwarm && Math.random() < 0.2) { s.visitedNodes.push({x: bot.x, y: bot.y, age: 150}); if (s.visitedNodes.length > 200) s.visitedNodes.shift(); }
            });

            s.targets = s.targets.filter(t => !t.consumed);
            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            ctx.fillStyle = isSwarm ? 'rgba(76, 5, 25, 0.4)' : 'rgba(67, 10, 10, 0.4)'; ctx.fillRect(0, 0, cw, ch);
            
            // Draw Obstacles (Tissue)
            ctx.fillStyle = 'rgba(159, 18, 57, 0.5)';
            ctx.strokeStyle = 'rgba(244, 63, 94, 0.4)';
            ctx.lineWidth = 1;
            obstacles.forEach(obs => { ctx.fillRect(obs.x, obs.y, obs.w, obs.h); ctx.strokeRect(obs.x, obs.y, obs.w, obs.h); });

            if (isSwarm) {
                s.visitedNodes.forEach(node => { ctx.beginPath(); ctx.arc(node.x, node.y, 4, 0, Math.PI*2); ctx.fillStyle = `rgba(244, 114, 182, ${node.age/1000})`; ctx.fill(); });
                ctx.lineWidth = 0.5;
                for(let i=0; i<s.bots.length; i++) {
                    for(let j=i+1; j<s.bots.length; j++) {
                        const b1 = s.bots[i]; const b2 = s.bots[j]; const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                        if (dx*dx + dy*dy < 10000) { ctx.beginPath(); ctx.moveTo(b1.x, b1.y); ctx.lineTo(b2.x, b2.y); ctx.strokeStyle = 'rgba(248, 113, 113, 0.4)'; ctx.stroke(); }
                    }
                }
            }

            s.targets.forEach(target => { ctx.beginPath(); ctx.arc(target.x, target.y, 6, 0, Math.PI*2); ctx.fillStyle = '#fef08a'; ctx.fill(); });
            s.bots.forEach(bot => { ctx.beginPath(); ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI*2); ctx.fillStyle = bot.color; ctx.fill(); });
          };

          const update = () => {
             updateEngine(simState.current.standard, canvasStandardRef.current, false);
             updateEngine(simState.current.swarm, canvasSwarmRef.current, true);
             requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => { requestRef.current = requestAnimationFrame(update); return () => cancelAnimationFrame(requestRef.current); }, []);

          const handleReset = () => {
             simState.current.standard.hits = 0; simState.current.swarm.hits = 0;
             simState.current.standard.targets = []; simState.current.swarm.targets = [];
             setStats({ standard: 0, swarm: 0 });
             localStorage.setItem('genesis_medical', JSON.stringify({ standard: 0, swarm: 0 }));
          };

          return (
             <div className="flex-1 flex flex-col xl:flex-row relative min-h-0 bg-slate-950 overflow-hidden">
                <aside className="w-full xl:w-72 flex-shrink-0 bg-rose-950/40 border-b xl:border-b-0 xl:border-r border-rose-900/50 p-4 overflow-y-auto backdrop-blur-sm z-10 max-h-[30%] md:max-h-none">
                  <section className="space-y-4">
                    <div className="flex items-center gap-2 mb-2">
                        <HeartPulse size={18} className="text-rose-400" />
                        <h2 className="text-xs font-bold uppercase tracking-wider text-rose-400">Medical Setup</h2>
                    </div>
                    <div className="p-3 bg-rose-900/20 rounded-xl border border-rose-500/30 hidden md:block">
                        <p className="text-[10px] text-slate-400 leading-relaxed">
                            Watch Method 1 get completely trapped by the tissue barriers. Watch Method 2 map the barriers and route out of the dead ends.
                        </p>
                    </div>
                    <div className="grid grid-cols-2 gap-2 md:grid-cols-1">
                        <div className="p-3 bg-orange-900/40 rounded-xl border border-orange-700/50 shadow-inner">
                            <div className="text-[9px] text-orange-300 uppercase font-bold mb-1">M1: Random Chaos</div>
                            <div className="text-xl font-mono text-white">{stats.standard}</div>
                        </div>
                        <div className="p-3 bg-emerald-900/40 rounded-xl border border-emerald-500/50 shadow-inner">
                            <div className="text-[9px] text-emerald-300 uppercase font-bold mb-1">M2: Holo Swarm</div>
                            <div className="text-xl font-mono text-white">{stats.swarm}</div>
                        </div>
                    </div>
                    <button onClick={handleReset} className="w-full flex items-center justify-center gap-2 py-2 rounded-xl border border-rose-800 hover:bg-rose-800/50 text-rose-300 font-semibold text-xs transition-colors">
                        <RefreshCw size={12} /> Reset A/B Stats
                    </button>
                  </section>
                </aside>
                
                <div className="flex-1 flex flex-col md:flex-row relative min-h-0">
                    <div className="flex-1 relative border-b md:border-b-0 md:border-r border-rose-900/50 overflow-hidden">
                        <canvas ref={canvasStandardRef} className="absolute inset-0 w-full h-full block bg-[#1a050f]" />
                        <div className="absolute top-2 left-2 bg-orange-950/90 px-2 py-1 rounded border border-orange-800 backdrop-blur-md pointer-events-none z-10">
                            <span className="text-[9px] font-bold text-orange-400 uppercase tracking-wider flex flex-col"><span className="text-[8px] text-orange-500/70">Method 1</span> Pure Chaos</span>
                        </div>
                    </div>
                    <div className="flex-1 relative overflow-hidden">
                        <canvas ref={canvasSwarmRef} className="absolute inset-0 w-full h-full block bg-[#1a050f]" />
                        <div className="absolute top-2 left-2 bg-emerald-950/90 px-2 py-1 rounded border border-emerald-800 backdrop-blur-md pointer-events-none z-10">
                            <span className="text-[9px] font-bold text-emerald-400 uppercase tracking-wider flex flex-col"><span className="text-[8px] text-emerald-500/70">Method 2</span> Smith/Blade</span>
                        </div>
                    </div>
                </div>
             </div>
          );
        };

        // ==========================================
        // TAB 4: TECH/DEEP LEARNING (TRAP MAZE)
        // ==========================================
        const TechSim = () => {
          const canvasStandardRef = useRef(null);
          const canvasSwarmRef = useRef(null);
          const requestRef = useRef(null);
          
          const [stats, setStats] = useState({ standard: 0, swarm: 0 });
          const simState = useRef({ 
            standard: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0, hits: 0, init: false },
            swarm: { bots: [], visitedNodes: [], targets: [], lastSpawn: 0, hits: 0, init: false }
          });

          useEffect(() => {
            const saved = JSON.parse(localStorage.getItem('genesis_tech') || '{}');
            simState.current.standard.hits = saved.standard || 0;
            simState.current.swarm.hits = saved.swarm || 0;
            const syncInterval = setInterval(() => {
                setStats({ standard: simState.current.standard.hits, swarm: simState.current.swarm.hits });
                localStorage.setItem('genesis_tech', JSON.stringify({ standard: simState.current.standard.hits, swarm: simState.current.swarm.hits }));
            }, 500);
            return () => clearInterval(syncInterval);
          }, []);

          useEffect(() => {
            const handleResize = () => {
              [canvasStandardRef.current, canvasSwarmRef.current].forEach(canvas => {
                if (canvas && canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; }
              });
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const updateEngine = (s, canvas, isSwarm) => {
            if (!canvas) return;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;

            // Define Tech "Local Minima" U-Traps
            const obstacles = [
                { x: cw * 0.3, y: ch * 0.3, w: cw * 0.4, h: Math.max(15, ch * 0.05) }, // Top of U-trap
                { x: cw * 0.3, y: ch * 0.3, w: Math.max(15, cw * 0.05), h: ch * 0.4 }, // Left of U-trap
                { x: cw * 0.7 - Math.max(15, cw * 0.05), y: ch * 0.3, w: Math.max(15, cw * 0.05), h: ch * 0.4 }, // Right of U-trap
                { x: 0, y: ch * 0.8, w: cw * 0.35, h: Math.max(15, ch * 0.05) }, // Bottom-left wall
                { x: cw * 0.65, y: ch * 0.8, w: cw * 0.35, h: Math.max(15, ch * 0.05) } // Bottom-right wall
            ];

            if (!s.init && cw > 0 && ch > 0) {
                s.bots = [];
                for(let i=0; i<20; i++) s.bots.push({ x: cw/2, y: ch*0.6, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, color: isSwarm ? '#34d399' : '#38bdf8', size: 3 });
                s.init = true;
            }
            if (!s.init) return;

            // Spawn Targets primarily near edges/corners to force exploration
            if (Date.now() - s.lastSpawn > 1500 && s.targets.length < 15) {
                const corners = [
                    { x: cw * 0.1, y: ch * 0.1 }, { x: cw * 0.9, y: ch * 0.1 },
                    { x: cw * 0.1, y: ch * 0.9 }, { x: cw * 0.9, y: ch * 0.9 }
                ];
                const corner = corners[Math.floor(Math.random() * corners.length)];
                s.targets.push({ x: corner.x + (Math.random()-0.5)*cw*0.1, y: corner.y + (Math.random()-0.5)*ch*0.1, consumed: false });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0; let attractX = 0; let attractY = 0; let minDist = Infinity;
                
                if (isSwarm) {
                    s.visitedNodes.forEach(node => {
                        const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 3000 && distSq > 0.1) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 0.5; repulseY += (dy/dist) * 0.5; }
                    });
                    
                    s.targets.forEach((target) => {
                        if (target.consumed) return;
                        const dx = target.x - bot.x; const dy = target.y - bot.y; const distSq = dx*dx + dy*dy;
                        if (distSq < 90000 && distSq < minDist) { minDist = distSq; const dist = Math.sqrt(distSq); attractX = (dx/dist) * 3.0; attractY = (dy/dist) * 3.0; }
                    });
                }

                s.targets.forEach((target) => {
                    if (target.consumed) return;
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const distSq = dx*dx + dy*dy;
                    if (distSq < 400) { target.consumed = true; s.hits += 1; }
                });

                if (isSwarm) {
                    if (Math.random() > 0.8) { if (Math.abs(bot.vx) > Math.abs(bot.vy)) bot.vy = 0; else bot.vx = 0; }
                    bot.vx += repulseX + attractX; bot.vy += repulseY + attractY;
                    const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                    if (speed > 5) { bot.vx = (bot.vx/speed)*5; bot.vy = (bot.vy/speed)*5; }
                } else {
                    bot.vx += (Math.random()-0.5) * 2.5; bot.vy += (Math.random()-0.5) * 2.5;
                    bot.vx *= 0.85; bot.vy *= 0.85; 
                }

                // X Axis Movement & Collision
                bot.x += bot.vx;
                if (bot.x < 0) {bot.x=0; bot.vx *= -1;} if (bot.x > cw) {bot.x=cw; bot.vx *= -1;}
                obstacles.forEach(obs => {
                    if (bot.x > obs.x && bot.x < obs.x + obs.w && bot.y > obs.y && bot.y < obs.y + obs.h) {
                        bot.x -= bot.vx; bot.vx *= -1;
                    }
                });

                // Y Axis Movement & Collision
                bot.y += bot.vy;
                if (bot.y < 0) {bot.y=0; bot.vy *= -1;} if (bot.y > ch) {bot.y=ch; bot.vy *= -1;}
                obstacles.forEach(obs => {
                    if (bot.x > obs.x && bot.x < obs.x + obs.w && bot.y > obs.y && bot.y < obs.y + obs.h) {
                        bot.y -= bot.vy; bot.vy *= -1;
                    }
                });

                if (isSwarm && Math.random() < 0.2) { s.visitedNodes.push({x: bot.x, y: bot.y, age: 100}); if (s.visitedNodes.length > 150) s.visitedNodes.shift(); }
            });

            s.targets = s.targets.filter(t => !t.consumed);
            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            ctx.fillStyle = isSwarm ? 'rgba(2, 6, 23, 0.5)' : 'rgba(15, 5, 5, 0.5)'; ctx.fillRect(0, 0, cw, ch);
            
            // Draw Obstacles (Data Silos)
            ctx.fillStyle = 'rgba(8, 47, 73, 0.6)';
            ctx.strokeStyle = 'rgba(14, 165, 233, 0.5)';
            ctx.lineWidth = 1;
            obstacles.forEach(obs => { ctx.fillRect(obs.x, obs.y, obs.w, obs.h); ctx.strokeRect(obs.x, obs.y, obs.w, obs.h); });

            if (isSwarm) {
                s.visitedNodes.forEach(node => { ctx.beginPath(); ctx.rect(node.x-2, node.y-2, 4, 4); ctx.fillStyle = `rgba(56, 189, 248, ${node.age/200})`; ctx.fill(); });
                ctx.lineWidth = 0.5;
                for(let i=0; i<s.bots.length; i++) {
                    for(let j=i+1; j<s.bots.length; j++) {
                        const b1 = s.bots[i]; const b2 = s.bots[j]; const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                        if (dx*dx + dy*dy < 10000) { ctx.beginPath(); ctx.moveTo(b1.x, b1.y); ctx.lineTo(b1.x, b2.y); ctx.lineTo(b2.x, b2.y); ctx.strokeStyle = 'rgba(56, 189, 248, 0.4)'; ctx.stroke(); }
                    }
                }
            }

            s.targets.forEach(target => { ctx.beginPath(); ctx.arc(target.x, target.y, 6, 0, Math.PI*2); ctx.fillStyle = 'rgba(244, 63, 94, 0.8)'; ctx.fill(); });
            s.bots.forEach(bot => { ctx.beginPath(); ctx.rect(bot.x-bot.size, bot.y-bot.size, bot.size*2, bot.size*2); ctx.fillStyle = bot.color; ctx.fill(); });
          };

          const update = () => {
             updateEngine(simState.current.standard, canvasStandardRef.current, false);
             updateEngine(simState.current.swarm, canvasSwarmRef.current, true);
             requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => { requestRef.current = requestAnimationFrame(update); return () => cancelAnimationFrame(requestRef.current); }, []);

          const handleReset = () => {
             simState.current.standard.hits = 0; simState.current.swarm.hits = 0;
             simState.current.standard.targets = []; simState.current.swarm.targets = [];
             setStats({ standard: 0, swarm: 0 });
             localStorage.setItem('genesis_tech', JSON.stringify({ standard: 0, swarm: 0 }));
          };

          return (
             <div className="flex-1 flex flex-col xl:flex-row relative min-h-0 bg-slate-950 overflow-hidden">
                <aside className="w-full xl:w-72 flex-shrink-0 bg-slate-900/80 border-b xl:border-b-0 xl:border-r border-sky-900/50 p-4 overflow-y-auto backdrop-blur-sm z-10 max-h-[30%] md:max-h-none">
                  <section className="space-y-4">
                    <div className="flex items-center gap-2 mb-2">
                        <CpuIcon size={18} className="text-sky-400" />
                        <h2 className="text-xs font-bold uppercase tracking-wider text-sky-400">Deep Learning</h2>
                    </div>
                    <div className="p-3 bg-slate-800/80 rounded-xl border border-sky-500/30 hidden md:block">
                        <p className="text-[10px] text-slate-400 leading-relaxed">
                            Left: Algorithms get trapped in "local minima" structures. Right: Swarm maps failures and actively repels out of traps.
                        </p>
                    </div>
                    <div className="grid grid-cols-2 gap-2 md:grid-cols-1">
                        <div className="p-3 bg-orange-900/40 rounded-xl border border-orange-700/50 shadow-inner">
                            <div className="text-[9px] text-orange-300 uppercase font-bold mb-1">M1: Blind GD</div>
                            <div className="text-xl font-mono text-white">{stats.standard}</div>
                        </div>
                        <div className="p-3 bg-emerald-900/40 rounded-xl border border-emerald-500/50 shadow-inner">
                            <div className="text-[9px] text-emerald-300 uppercase font-bold mb-1">M2: Holo Swarm</div>
                            <div className="text-xl font-mono text-white">{stats.swarm}</div>
                        </div>
                    </div>
                    <button onClick={handleReset} className="w-full flex items-center justify-center gap-2 py-2 rounded-xl border border-sky-800 hover:bg-sky-800/50 text-sky-300 font-semibold text-xs transition-colors">
                        <RefreshCw size={12} /> Reset A/B Stats
                    </button>
                  </section>
                </aside>
                
                <div className="flex-1 flex flex-col md:flex-row relative min-h-0">
                    <div className="flex-1 relative border-b md:border-b-0 md:border-r border-slate-800 overflow-hidden">
                        <canvas ref={canvasStandardRef} className="absolute inset-0 w-full h-full block bg-[#0f0505]" />
                        <div className="absolute top-2 left-2 bg-orange-950/90 px-2 py-1 rounded border border-orange-800 backdrop-blur-md pointer-events-none z-10">
                            <span className="text-[9px] font-bold text-orange-400 uppercase tracking-wider flex flex-col"><span className="text-[8px] text-orange-500/70">Method 1</span> Get Stuck (GD)</span>
                        </div>
                    </div>
                    <div className="flex-1 relative overflow-hidden">
                        <canvas ref={canvasSwarmRef} className="absolute inset-0 w-full h-full block bg-[#020617]" />
                        <div className="absolute top-2 left-2 bg-emerald-950/90 px-2 py-1 rounded border border-emerald-800 backdrop-blur-md pointer-events-none z-10">
                            <span className="text-[9px] font-bold text-emerald-400 uppercase tracking-wider flex flex-col"><span className="text-[8px] text-emerald-500/70">Method 2</span> Swarm Optimizer</span>
                        </div>
                    </div>
                </div>
             </div>
          );
        };

        // ==========================================
        // MAIN APP CONTAINER
        // ==========================================
        const App = () => {
          const [activeTab, setActiveTab] = useState(1);

          return (
            <div className="flex flex-col h-[100dvh] bg-slate-950 text-slate-100 font-sans overflow-hidden">
              <header className="flex flex-col md:flex-row items-start md:items-center justify-between px-4 md:px-6 py-3 bg-slate-900/80 border-b border-slate-800 backdrop-blur-md z-20 gap-4 shadow-xl flex-shrink-0">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-indigo-500/20 rounded-lg text-indigo-400">
                    <Activity size={24} />
                  </div>
                  <div>
                    <h1 className="text-lg md:text-xl font-bold tracking-tight">Project Genesis</h1>
                    <p className="text-[10px] md:text-xs text-slate-400 uppercase tracking-widest font-medium">Multi-Disciplinary Simulations</p>
                  </div>
                </div>

                <div className="flex w-full md:w-auto overflow-x-auto pb-2 md:pb-0 scrollbar-hide">
                    <div className="flex bg-slate-800/50 p-1 rounded-xl min-w-max">
                        <button onClick={() => setActiveTab(1)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 1 ? 'bg-indigo-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <BoxIcon size={16} /> <span className="hidden sm:inline">Billiard</span> Inversion
                        </button>
                        <button onClick={() => setActiveTab(2)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 2 ? 'bg-emerald-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <NetworkIcon size={16} /> Zeta Swarm
                        </button>
                        <button onClick={() => setActiveTab(3)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 3 ? 'bg-rose-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <HeartPulse size={16} /> Medicine (A/B)
                        </button>
                        <button onClick={() => setActiveTab(4)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 4 ? 'bg-sky-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <CpuIcon size={16} /> Tech / DL (A/B)
                        </button>
                    </div>
                </div>
              </header>

              <main className="flex-1 flex flex-col relative min-h-0 overflow-hidden">
                {activeTab === 1 && <BilliardSim />}
                {activeTab === 2 && <ZetaSwarmSim />}
                {activeTab === 3 && <MedicalSim />}
                {activeTab === 4 && <TechSim />}
              </main>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <style>
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</body>
</html>