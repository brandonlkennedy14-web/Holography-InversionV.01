<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Genesis: Holography & Swarm Logic</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- Load Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-950 text-slate-100 font-sans overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Inline Icons ---
        const Activity = ({size=24}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>;
        const Play = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const Pause = ({size=18}) => <svg width={size} height={size} fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const RefreshCw = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;
        const BoxIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const NetworkIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>;
        const HeartPulse = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"></path><path d="M3.22 12H9.5l.5-1 2 4.5 2-7 1.5 3.5h5.27"></path></svg>;
        const CpuIcon = ({size=16}) => <svg width={size} height={size} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>;

        // ==========================================
        // TAB 1: ORIGINAL BILLIARD INVERSION
        // ==========================================
        const BilliardSim = () => {
          const [isRunning, setIsRunning] = useState(false);
          const [precision, setPrecision] = useState(0.001);
          const [inversionRadius, setInversionRadius] = useState(150);
          const [speed, setSpeed] = useState(2);
          const [windingNumber, setWindingNumber] = useState(0);
          const [cornerHits, setCornerHits] = useState(0);
          const [trailLength, setTrailLength] = useState(5000);
          const [showInversionCircle, setShowInversionCircle] = useState(true);

          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const stateRef = useRef({ pos: { x: 50, y: 50 }, vel: { x: 1.5, y: 1.2 }, path: [], bounds: { size: 300 } });

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              const container = canvas.parentElement;
              if (container) { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100); 
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const invertPoint = (x, y, cx, cy, r) => {
            const dx = x - cx; const dy = y - cy; const distSq = dx * dx + dy * dy;
            if (distSq === 0) return { x, y };
            const factor = (r * r) / distSq;
            return { x: cx + dx * factor, y: cy + dy * factor };
          };

          const update = () => {
            const s = stateRef.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const cx = canvas.width / 2; const cy = canvas.height / 2; const halfSize = s.bounds.size / 2;

            for (let i = 0; i < speed; i++) {
              s.pos.x += s.vel.x; s.pos.y += s.vel.y;
              const left = cx - halfSize; const right = cx + halfSize; const top = cy - halfSize; const bottom = cy + halfSize;
              let hitCornerX = false; let hitCornerY = false;

              if (s.pos.x <= left || s.pos.x >= right) {
                s.vel.x *= -1; s.pos.x = s.pos.x <= left ? left : right;
                if (Math.abs(s.pos.y - top) < 5 || Math.abs(s.pos.y - bottom) < 5) hitCornerX = true;
              }
              if (s.pos.y <= top || s.pos.y >= bottom) {
                s.vel.y *= -1; s.pos.y = s.pos.y <= top ? top : bottom;
                if (Math.abs(s.pos.x - left) < 5 || Math.abs(s.pos.x - right) < 5) hitCornerY = true;
              }

              if (hitCornerX || hitCornerY) {
                setCornerHits(prev => prev + 1);
                setWindingNumber(prev => prev + (s.vel.x * s.vel.y > 0 ? 1 : -1));
              }

              const inverted = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
              s.path.push(inverted);
              if (s.path.length > trailLength) s.path.shift();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (showInversionCircle) {
              ctx.beginPath(); ctx.arc(cx, cy, inversionRadius, 0, Math.PI * 2);
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }

            ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
            ctx.strokeRect(cx - halfSize, cy - halfSize, s.bounds.size, s.bounds.size);

            if (s.path.length > 1) {
              ctx.beginPath(); ctx.moveTo(s.path[0].x, s.path[0].y);
              for (let i = 1; i < s.path.length; i++) ctx.lineTo(s.path[i].x, s.path[i].y);
              const gradient = ctx.createRadialGradient(cx, cy, 10, cx, cy, inversionRadius * 2);
              gradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)'); gradient.addColorStop(1, 'rgba(236, 72, 153, 0.1)');
              ctx.strokeStyle = gradient; ctx.lineWidth = 1.5; ctx.stroke();
            }

            const currentInv = invertPoint(s.pos.x, s.pos.y, cx, cy, inversionRadius);
            ctx.beginPath(); ctx.arc(currentInv.x, currentInv.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#f472b6'; ctx.shadowBlur = 10; ctx.shadowColor = '#f472b6'; ctx.fill(); ctx.shadowBlur = 0;

            requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning, speed, inversionRadius, trailLength]);

          const resetSimulation = () => {
            if (canvasRef.current) {
              stateRef.current.path = [];
              stateRef.current.pos = { x: canvasRef.current.width / 2 + 20, y: canvasRef.current.height / 2 + 20 };
              setCornerHits(0); setWindingNumber(0);
            }
          };

          return (
            <div className="flex-1 flex flex-col md:flex-row relative overflow-hidden">
                <aside className="w-full md:w-80 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10 max-h-[35vh] md:max-h-none">
                  <section className="space-y-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-indigo-400">Controls</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-indigo-500'}`}>{isRunning ? 'Pause' : 'Start'}</button>
                    </div>
                    <div>
                      <div className="space-y-4">
                        <div className="space-y-2">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Inversion Radius</label><span className="text-indigo-400 font-mono">{inversionRadius}px</span></div>
                          <input type="range" min="50" max="300" value={inversionRadius} onChange={(e) => setInversionRadius(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                        <div className="space-y-2">
                          <div className="flex justify-between text-xs"><label className="text-slate-400">Speed</label><span className="text-indigo-400 font-mono">x{speed}</span></div>
                          <input type="range" min="1" max="10" value={speed} onChange={(e) => setSpeed(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer" />
                        </div>
                      </div>
                    </div>
                    <div className="pt-4 border-t border-slate-800 space-y-3">
                        <label className="flex items-center justify-between p-2 md:p-3 bg-slate-800/30 rounded-xl cursor-pointer hover:bg-slate-800/50">
                          <span className="text-xs md:text-sm font-medium">Show Inversion Circle</span>
                          <input type="checkbox" checked={showInversionCircle} onChange={() => setShowInversionCircle(!showInversionCircle)} className="w-4 h-4 rounded accent-indigo-500" />
                        </label>
                        <button onClick={resetSimulation} className="w-full flex items-center justify-center gap-2 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-slate-300 font-semibold text-sm">
                          <RefreshCw size={14} /> Reset Path
                        </button>
                    </div>
                  </section>
                </aside>

                <div className="flex-1 min-h-[50vh] bg-[radial-gradient(circle_at_center,_#111827_0%,_#020617_100%)] relative">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                  <div className="absolute bottom-4 left-4 right-4 flex justify-between items-end pointer-events-none">
                    <div className="bg-slate-900/80 backdrop-blur-md border border-slate-800 p-3 rounded-xl min-w-[150px] shadow-2xl">
                      <div className="flex justify-between text-xs mb-1"><span className="text-slate-500">Winding</span><span className="text-emerald-400 font-mono">{windingNumber}</span></div>
                      <div className="flex justify-between text-xs"><span className="text-slate-500">Corners</span><span className="text-amber-400 font-mono">{cornerHits}</span></div>
                    </div>
                  </div>
                </div>
            </div>
          );
        };

        // ==========================================
        // TAB 2: ZETA SWARM (SMITH & BLADE LOGIC)
        // ==========================================
        const ZetaSwarmSim = () => {
          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const [zetaSorted, setZetaSorted] = useState(0);
          const [isRunning, setIsRunning] = useState(true);

          const simState = useRef({ bots: [], visitedNodes: [], zetaTargets: [], lastSpawn: 0 });

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              const container = canvas.parentElement;
              if (container) { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);

            const bots = [];
            for(let i=0; i<3; i++) bots.push({ id: `g1_${i}`, group: 1, x: window.innerWidth/2 + (Math.random()-0.5)*100, y: window.innerHeight - 100, vx: (Math.random()-0.5)*2, vy: -2 - Math.random(), color: '#22d3ee', size: 4 });
            for(let i=0; i<5; i++) bots.push({ id: `g2_${i}`, group: 2, x: window.innerWidth/2 + (Math.random()-0.5)*200, y: 100, vx: (Math.random()-0.5)*2, vy: 2 + Math.random(), color: '#fb7185', size: 3 });
            for(let i=0; i<7; i++) {
                const angle = (i / 7) * Math.PI * 2;
                bots.push({ id: `g3_${i}`, group: 3, x: window.innerWidth/2, y: window.innerHeight/2, vx: Math.cos(angle)*1.5, vy: Math.sin(angle)*1.5, color: '#fbbf24', size: 3 });
            }
            simState.current.bots = bots;
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const update = () => {
            const s = simState.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;

            if (Date.now() - s.lastSpawn > 1000 && s.zetaTargets.length < 30) {
                s.zetaTargets.push({ x: Math.random() * cw, y: Math.random() * ch, val: Math.floor(Math.random()*1000) });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0;
                s.visitedNodes.forEach(node => {
                    const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                    if (distSq < 4000) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 0.5; repulseY += (dy/dist) * 0.5; }
                });

                let attractX = 0; let attractY = 0; let minDist = Infinity;
                s.zetaTargets.forEach((target, index) => {
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 100 && dist < minDist) { minDist = dist; attractX = dx/dist; attractY = dy/dist; }
                    if (dist < 15) { s.zetaTargets.splice(index, 1); setZetaSorted(prev => prev + 1); }
                });

                let dirX = 0; let dirY = 0;
                if (bot.group === 1) dirY = -0.5;
                if (bot.group === 2) dirY = 0.5;
                if (bot.group === 3) { dirX = (bot.x - cw/2) > 0 ? 0.2 : -0.2; dirY = (bot.y - ch/2) > 0 ? 0.2 : -0.2; }

                bot.vx += repulseX + attractX * 0.5 + dirX; bot.vy += repulseY + attractY * 0.5 + dirY;
                const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                if (speed > 3) { bot.vx = (bot.vx/speed)*3; bot.vy = (bot.vy/speed)*3; }

                bot.x += bot.vx; bot.y += bot.vy;
                if (bot.x < 0 || bot.x > cw) bot.vx *= -1;
                if (bot.y < 0 || bot.y > ch) bot.vy *= -1;

                if (Math.random() < 0.1) {
                    s.visitedNodes.push({x: bot.x, y: bot.y, age: 255});
                    if (s.visitedNodes.length > 200) s.visitedNodes.shift();
                }
            });

            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            ctx.fillStyle = 'rgba(15, 23, 42, 0.3)'; ctx.fillRect(0, 0, cw, ch);
            s.visitedNodes.forEach(node => {
                ctx.beginPath(); ctx.arc(node.x, node.y, 2, 0, Math.PI*2);
                ctx.fillStyle = `rgba(255, 255, 255, ${node.age/1000})`; ctx.fill();
            });

            s.zetaTargets.forEach(target => {
                ctx.beginPath(); ctx.rect(target.x-4, target.y-4, 8, 8);
                ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 1; ctx.stroke();
                ctx.fillStyle = 'rgba(74, 222, 128, 0.2)'; ctx.fill();
            });

            ctx.lineWidth = 0.5;
            for(let i=0; i<s.bots.length; i++) {
                for(let j=i+1; j<s.bots.length; j++) {
                    const b1 = s.bots[i]; const b2 = s.bots[j];
                    if (b1.group === b2.group) {
                        const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                        if (dx*dx + dy*dy < 20000) { ctx.beginPath(); ctx.moveTo(b1.x, b1.y); ctx.lineTo(b2.x, b2.y); ctx.strokeStyle = b1.color + '40'; ctx.stroke(); }
                    }
                }
            }

            s.bots.forEach(bot => {
                ctx.beginPath(); ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI*2);
                ctx.fillStyle = bot.color; ctx.shadowBlur = 10; ctx.shadowColor = bot.color; ctx.fill(); ctx.shadowBlur = 0;
            });

            if (isRunning) requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => {
            if (isRunning) requestRef.current = requestAnimationFrame(update);
            else if (requestRef.current) cancelAnimationFrame(requestRef.current);
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isRunning]);

          return (
             <div className="flex-1 flex flex-col md:flex-row relative overflow-hidden">
                <aside className="w-full md:w-80 bg-slate-900/30 border-b md:border-b-0 md:border-r border-slate-800 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10">
                  <section className="space-y-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-sm font-bold uppercase tracking-wider text-emerald-400">Swarm Protocol</h2>
                        <button onClick={() => setIsRunning(!isRunning)} className={`px-4 py-1.5 rounded-full text-xs font-bold ${isRunning ? 'bg-rose-500' : 'bg-emerald-500'}`}>{isRunning ? 'Halt 24/7' : 'Resume 24/7'}</button>
                    </div>

                    <div className="p-4 bg-slate-800/50 rounded-xl border border-slate-700">
                        <div className="text-xs text-slate-400 uppercase font-bold mb-1">Zeta Numbers Sorted</div>
                        <div className="text-3xl font-mono text-emerald-400">{zetaSorted.toLocaleString()}</div>
                        <div className="text-[10px] text-slate-500 mt-2">Continuous 24/7 parsing via Smith & Blade logic.</div>
                    </div>

                    <div className="space-y-3">
                        <h3 className="text-xs font-bold uppercase tracking-wider text-slate-500 mb-2">Active Squads</h3>
                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-cyan-500/20"><div className="w-3 h-3 rounded-full bg-cyan-400 shadow-[0_0_8px_rgba(34,211,238,0.8)]"></div><div><div className="text-sm font-bold text-slate-200">Group 1 (3 Bots)</div><div className="text-[10px] text-slate-400 uppercase">Directive: Upward Sweep</div></div></div>
                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-rose-500/20"><div className="w-3 h-3 rounded-full bg-rose-400 shadow-[0_0_8px_rgba(251,113,133,0.8)]"></div><div><div className="text-sm font-bold text-slate-200">Group 2 (5 Bots)</div><div className="text-[10px] text-slate-400 uppercase">Directive: Downward Sweep</div></div></div>
                        <div className="flex items-center gap-3 p-3 bg-slate-800/30 rounded-lg border border-amber-500/20"><div className="w-3 h-3 rounded-full bg-amber-400 shadow-[0_0_8px_rgba(251,191,36,0.8)]"></div><div><div className="text-sm font-bold text-slate-200">Group 3 (7 Bots)</div><div className="text-[10px] text-slate-400 uppercase">Directive: Radial Expansion</div></div></div>
                    </div>
                  </section>
                </aside>
                <div className="flex-1 min-h-[50vh] bg-slate-950 relative">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                </div>
             </div>
          );
        };

        // ==========================================
        // TAB 3: MEDICAL APPLICATION (TISSUE SCANNING)
        // ==========================================
        const MedicalSim = () => {
          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const [anomaliesFound, setAnomaliesFound] = useState(0);
          const simState = useRef({ bots: [], visitedNodes: [], targets: [], lastSpawn: 0 });

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              const container = canvas.parentElement;
              if (container) { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);

            const bots = [];
            // "Nano-diagnostics / White blood cells"
            for(let i=0; i<15; i++) bots.push({ x: window.innerWidth/2, y: window.innerHeight/2, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, color: '#f8fafc', size: 5 });
            simState.current.bots = bots;
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const update = () => {
            const s = simState.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;

            if (Date.now() - s.lastSpawn > 2000 && s.targets.length < 10) {
                s.targets.push({ x: Math.random() * cw, y: Math.random() * ch });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0;
                s.visitedNodes.forEach(node => {
                    const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                    if (distSq < 5000) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 0.8; repulseY += (dy/dist) * 0.8; }
                });

                let attractX = 0; let attractY = 0; let minDist = Infinity;
                s.targets.forEach((target, index) => {
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 150 && dist < minDist) { minDist = dist; attractX = dx/dist; attractY = dy/dist; }
                    if (dist < 20) { s.targets.splice(index, 1); setAnomaliesFound(prev => prev + 1); }
                });

                bot.vx += repulseX + attractX * 1.2 + (Math.random()-0.5)*0.5; // add organic jitter
                bot.vy += repulseY + attractY * 1.2 + (Math.random()-0.5)*0.5;
                const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                if (speed > 2.5) { bot.vx = (bot.vx/speed)*2.5; bot.vy = (bot.vy/speed)*2.5; }

                bot.x += bot.vx; bot.y += bot.vy;
                if (bot.x < 0 || bot.x > cw) bot.vx *= -1;
                if (bot.y < 0 || bot.y > ch) bot.vy *= -1;

                if (Math.random() < 0.2) {
                    s.visitedNodes.push({x: bot.x, y: bot.y, age: 300});
                    if (s.visitedNodes.length > 300) s.visitedNodes.shift();
                }
            });

            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            // Organic Tissue Background
            ctx.fillStyle = 'rgba(76, 5, 25, 0.4)'; 
            ctx.fillRect(0, 0, cw, ch);
            
            s.visitedNodes.forEach(node => {
                ctx.beginPath(); ctx.arc(node.x, node.y, 4, 0, Math.PI*2);
                ctx.fillStyle = `rgba(244, 114, 182, ${node.age/1500})`; ctx.fill(); // Pink fading trail
            });

            s.targets.forEach(target => {
                ctx.beginPath(); ctx.arc(target.x, target.y, 8, 0, Math.PI*2);
                ctx.fillStyle = '#fef08a'; ctx.shadowBlur = 15; ctx.shadowColor = '#eab308'; ctx.fill(); ctx.shadowBlur = 0;
            });

            s.bots.forEach(bot => {
                ctx.beginPath(); ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI*2);
                ctx.fillStyle = bot.color; ctx.shadowBlur = 8; ctx.shadowColor = '#ffffff'; ctx.fill(); ctx.shadowBlur = 0;
            });

            requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => { requestRef.current = requestAnimationFrame(update); return () => cancelAnimationFrame(requestRef.current); }, []);

          return (
             <div className="flex-1 flex flex-col md:flex-row relative overflow-hidden">
                <aside className="w-full md:w-80 bg-rose-950/40 border-b md:border-b-0 md:border-r border-rose-900/50 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10">
                  <section className="space-y-6">
                    <div className="flex items-center gap-2 mb-4">
                        <HeartPulse size={20} className="text-rose-400" />
                        <h2 className="text-sm font-bold uppercase tracking-wider text-rose-400">Medical Application</h2>
                    </div>

                    <div className="p-4 bg-rose-900/20 rounded-xl border border-rose-500/30">
                        <div className="text-sm text-slate-200 font-bold mb-2">Autonomous Diagnostics & Delivery</div>
                        <p className="text-xs text-slate-400 leading-relaxed mb-4">
                            You don't need to understand complex winding numbers to see the benefit. By applying the "Smith & Blade" shared-memory logic, we can deploy bio-compatible nano-swarms into the bloodstream or tissue. 
                        </p>
                        <p className="text-xs text-slate-400 leading-relaxed mb-4">
                            <strong>Why it matters:</strong> Instead of blindly circulating, these agents communicate where they have already searched (the pink trails). This ensures 100% coverage of an organ without redundant mapping.
                        </p>
                    </div>

                    <div className="p-4 bg-rose-900/40 rounded-xl border border-rose-500/50">
                        <div className="text-xs text-rose-300 uppercase font-bold mb-1">Pathogens/Anomalies Isolated</div>
                        <div className="text-3xl font-mono text-white">{anomaliesFound}</div>
                    </div>
                  </section>
                </aside>
                <div className="flex-1 min-h-[50vh] bg-[radial-gradient(circle_at_center,_#881337_0%,_#2e020f_100%)] relative">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                </div>
             </div>
          );
        };

        // ==========================================
        // TAB 4: TECH/DEEP LEARNING APPLICATION
        // ==========================================
        const TechSim = () => {
          const canvasRef = useRef(null);
          const requestRef = useRef(null);
          const [lossOptimized, setLossOptimized] = useState(0);
          const simState = useRef({ bots: [], visitedNodes: [], targets: [], lastSpawn: 0 });

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const handleResize = () => {
              const container = canvas.parentElement;
              if (container) { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            };
            window.addEventListener('resize', handleResize);
            setTimeout(handleResize, 100);

            const bots = [];
            // "Network Optimizers / Weight Adjusters"
            for(let i=0; i<20; i++) bots.push({ x: window.innerWidth/2, y: window.innerHeight/2, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, color: '#38bdf8', size: 3 });
            simState.current.bots = bots;
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          const update = () => {
            const s = simState.current; const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d'); const cw = canvas.width; const ch = canvas.height;

            if (Date.now() - s.lastSpawn > 1500 && s.targets.length < 15) {
                // Snap targets to a grid logic to look "techy"
                s.targets.push({ x: Math.floor(Math.random() * (cw/40))*40, y: Math.floor(Math.random() * (ch/40))*40 });
                s.lastSpawn = Date.now();
            }

            s.bots.forEach(bot => {
                let repulseX = 0; let repulseY = 0;
                s.visitedNodes.forEach(node => {
                    const dx = bot.x - node.x; const dy = bot.y - node.y; const distSq = dx*dx + dy*dy;
                    if (distSq < 3000) { const dist = Math.sqrt(distSq); repulseX += (dx/dist) * 1.5; repulseY += (dy/dist) * 1.5; }
                });

                let attractX = 0; let attractY = 0; let minDist = Infinity;
                s.targets.forEach((target, index) => {
                    const dx = target.x - bot.x; const dy = target.y - bot.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 200 && dist < minDist) { minDist = dist; attractX = dx/dist; attractY = dy/dist; }
                    if (dist < 15) { s.targets.splice(index, 1); setLossOptimized(prev => prev + 1); }
                });

                // Move strictly horizontally or vertically for a "routing/grid" feel sometimes
                if (Math.random() > 0.8) {
                    if (Math.abs(bot.vx) > Math.abs(bot.vy)) bot.vy = 0; else bot.vx = 0;
                }

                bot.vx += repulseX + attractX; bot.vy += repulseY + attractY;
                const speed = Math.sqrt(bot.vx*bot.vx + bot.vy*bot.vy);
                if (speed > 4) { bot.vx = (bot.vx/speed)*4; bot.vy = (bot.vy/speed)*4; }

                bot.x += bot.vx; bot.y += bot.vy;
                if (bot.x < 0 || bot.x > cw) bot.vx *= -1;
                if (bot.y < 0 || bot.y > ch) bot.vy *= -1;

                if (Math.random() < 0.3) {
                    s.visitedNodes.push({x: bot.x, y: bot.y, age: 100});
                    if (s.visitedNodes.length > 150) s.visitedNodes.shift();
                }
            });

            s.visitedNodes.forEach(n => n.age -= 1); s.visitedNodes = s.visitedNodes.filter(n => n.age > 0);

            // Cyber Grid Background
            ctx.fillStyle = 'rgba(2, 6, 23, 0.5)'; 
            ctx.fillRect(0, 0, cw, ch);
            ctx.strokeStyle = 'rgba(56, 189, 248, 0.05)';
            ctx.lineWidth = 1;
            for(let i=0; i<cw; i+=40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, ch); ctx.stroke(); }
            for(let i=0; i<ch; i+=40) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(cw, i); ctx.stroke(); }

            s.visitedNodes.forEach(node => {
                ctx.beginPath(); ctx.rect(node.x-2, node.y-2, 4, 4);
                ctx.fillStyle = `rgba(56, 189, 248, ${node.age/200})`; ctx.fill(); 
            });

            s.targets.forEach(target => {
                ctx.beginPath(); ctx.arc(target.x, target.y, 6, 0, Math.PI*2);
                ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = 'rgba(244, 63, 94, 0.2)'; ctx.fill();
            });

            // Draw angular connections between tech bots
            ctx.lineWidth = 0.5;
            for(let i=0; i<s.bots.length; i++) {
                for(let j=i+1; j<s.bots.length; j++) {
                    const b1 = s.bots[i]; const b2 = s.bots[j];
                    const dx = b1.x - b2.x; const dy = b1.y - b2.y;
                    if (dx*dx + dy*dy < 10000) { 
                        ctx.beginPath(); ctx.moveTo(b1.x, b1.y); 
                        ctx.lineTo(b1.x, b2.y); // Angular Manhattan line
                        ctx.lineTo(b2.x, b2.y); 
                        ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)'; ctx.stroke(); 
                    }
                }
            }

            s.bots.forEach(bot => {
                ctx.beginPath(); ctx.rect(bot.x-bot.size, bot.y-bot.size, bot.size*2, bot.size*2);
                ctx.fillStyle = bot.color; ctx.fill();
            });

            requestRef.current = requestAnimationFrame(update);
          };

          useEffect(() => { requestRef.current = requestAnimationFrame(update); return () => cancelAnimationFrame(requestRef.current); }, []);

          return (
             <div className="flex-1 flex flex-col md:flex-row relative overflow-hidden">
                <aside className="w-full md:w-80 bg-slate-900/80 border-b md:border-b-0 md:border-r border-sky-900/50 p-4 md:p-6 overflow-y-auto backdrop-blur-sm z-10">
                  <section className="space-y-6">
                    <div className="flex items-center gap-2 mb-4">
                        <CpuIcon size={20} className="text-sky-400" />
                        <h2 className="text-sm font-bold uppercase tracking-wider text-sky-400">Deep Learning App</h2>
                    </div>

                    <div className="p-4 bg-slate-800/80 rounded-xl border border-sky-500/30">
                        <div className="text-sm text-slate-200 font-bold mb-2">Loss Landscape Optimization</div>
                        <p className="text-xs text-slate-400 leading-relaxed mb-4">
                            Training neural networks requires searching massive, multi-dimensional "landscapes" for the lowest possible error rate (global minima). 
                        </p>
                        <p className="text-xs text-slate-400 leading-relaxed mb-4">
                            <strong>Why it matters:</strong> Standard AI often gets stuck in "local minima" (dead ends). By treating parameter weights as a Swarm that maps "high loss" areas and repels away from them via holographic folding, we train networks faster and cheaper, automating anomaly detection.
                        </p>
                    </div>

                    <div className="p-4 bg-sky-900/20 rounded-xl border border-sky-500/50">
                        <div className="text-xs text-sky-300 uppercase font-bold mb-1">Global Minima Reached</div>
                        <div className="text-3xl font-mono text-white">{lossOptimized}</div>
                    </div>
                  </section>
                </aside>
                <div className="flex-1 min-h-[50vh] bg-slate-950 relative">
                  <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
                </div>
             </div>
          );
        };

        // ==========================================
        // MAIN APP CONTAINER (TAB LOGIC)
        // ==========================================
        const App = () => {
          const [activeTab, setActiveTab] = useState(1);

          return (
            <div className="flex flex-col h-screen bg-slate-950 text-slate-100 font-sans overflow-hidden">
              <header className="flex flex-col md:flex-row items-start md:items-center justify-between px-4 md:px-6 py-3 bg-slate-900/80 border-b border-slate-800 backdrop-blur-md z-20 gap-4 shadow-xl">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-indigo-500/20 rounded-lg text-indigo-400">
                    <Activity size={24} />
                  </div>
                  <div>
                    <h1 className="text-lg md:text-xl font-bold tracking-tight">Project Genesis</h1>
                    <p className="text-[10px] md:text-xs text-slate-400 uppercase tracking-widest font-medium">Multi-Disciplinary Simulations</p>
                  </div>
                </div>

                {/* Tab Navigation - Scrollable on Mobile */}
                <div className="flex w-full md:w-auto overflow-x-auto pb-2 md:pb-0 scrollbar-hide">
                    <div className="flex bg-slate-800/50 p-1 rounded-xl min-w-max">
                        <button onClick={() => setActiveTab(1)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 1 ? 'bg-indigo-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <BoxIcon size={16} /> <span className="hidden sm:inline">Billiard</span> Inversion
                        </button>
                        <button onClick={() => setActiveTab(2)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 2 ? 'bg-emerald-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <NetworkIcon size={16} /> Zeta Swarm
                        </button>
                        <button onClick={() => setActiveTab(3)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 3 ? 'bg-rose-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <HeartPulse size={16} /> Medicine
                        </button>
                        <button onClick={() => setActiveTab(4)} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all ${activeTab === 4 ? 'bg-sky-500 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>
                            <CpuIcon size={16} /> Tech / DL
                        </button>
                    </div>
                </div>
              </header>

              <main className="flex-1 flex flex-col relative overflow-hidden">
                {activeTab === 1 && <BilliardSim />}
                {activeTab === 2 && <ZetaSwarmSim />}
                {activeTab === 3 && <MedicalSim />}
                {activeTab === 4 && <TechSim />}
              </main>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <style>
        /* Hide scrollbar for the tab menu on mobile */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</body>
</html>